Какие уровни доступа есть у класса на верхнем уровне, т.е. у внешнего класса?
**Ответ** private, protected, default, public.

Что является членами класса?
**Ответ** Методы и переменные внутри класса являются членами класса.

Что еще можно определить в классе кроме членов?
**Ответ** Конструкторы, объекты.

Какие уровни доступа есть у членов класса?
**Ответ** private, protected, default, public.

Какие модификаторы необходимы для определения константы:
	1. класса,
	2. экземпляра класса?
**Ответ** Для класса используется static final, а для экземпляра final.

Обратный вопрос. Допустим, у некоторого класса есть 4 следующих поля:
```java
	class SomeClass {
		private int a;
		private final int b;
	private static int c;
	private static final int D;
	...
	}
```
	Как можно назвать данные поля в зависимости от комбинации модификаторов static и final?
**Ответ** 
```java
	  private int a - неконстантное поле;
	  private final int b - константа экземпляра класса;
	  private static int c - статическое поле класса;
	  private static final int D - константа класса;
```

Может ли класс не иметь ни одного конструктора? Почему?
**Ответ** Конструктор имеется в любом классе. Даже если вы его не написали, компилятор Java
сам создаст конструктор по умолчанию (default constructor), который будет пустым и не делает ничего,
кроме вызова конструктора суперкласса.
**Источник** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

Перечислите отличия конструктора от метода.
**Ответ** Конструктор - это специальный метод, который вызывается при создании нового объекта. 
Конструктор имеет такое же название как и класс, но не имеет возвращаемого значения. 
Конструктор вызывается в месте выполнения оператора new.
**Источник** http://www.quizful.net/interview/java/constructor-vs-method

Как и в каком месте можно вызвать из одного конструктора другой конструктор этого же класса?
**Ответ** В первой строке конструктора этоко же класса при помощи ключевого слова this.

Как и в каком месте можно вызвать конструктор суперкласса?
**Ответ** В конструкторе подкласса при помощи ключевого слова super.

Что делает компилятор, если в конструкторе нет вызова другого конструктора или конструктора суперкласса?
**Ответ** Компилятор добавит их неявно.

Можно ли одновременно использовать конструкции this() и super() в одном и том же конструкторе?
	Обоснуйте ответ.
**Ответ** Нет, так как this(...) вызовет другой конструктор в том же классе, тогда как super() вызовет супер-конструктор. 
Если в конструкторе нет super(), компилятор добавит его неявно.
Таким образом, если бы оба были разрешены, вы могли бы дважды вызвать конструктор super.

Может ли быть приватный уровень доступа у конструктора? Если да, то для каких целей он необходим?
**Ответ** Да.Это значит, что вы можете управлять тем, как создается экземпляр класса. Если вы сделаете конструктор закрытым, а затем создайте видимый метод конструктора, который возвращает экземпляры класса, вы можете делать такие вещи, как ограничение количества созданий (как правило, гарантируется только один экземпляр) или экземпляры рециркуляции или другие связанные с строительством задачи.
**Источник** https://fooobar.com/questions/36342/can-a-constructor-in-java-be-private

Какие модификаторы может иметь конструктор?
**Ответ** В конструкторе допускается применение модификаторов доступа, можно задать один из модификаторов: public, protected, private или без модификатора.
**Источник** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

Конструктор принадлежит классу или экземпляру класса?
**Ответ** Конструктор принадлежит классу. Конструктор класса инициализирует экземпляры (объекты) этого класса. Обычно конструктор инициализирует поля объекта, которые необходимо инициализировать. Конструкторы также могут принимать параметры, поэтому поля могут быть инициализированы в объекте во время создания.
**Источник** https://javahelp.online/osnovy/konstruktor-java-obektov-klassov

Можно ли наследовать конструктор?
	Если да, то приведите примеры.
**Ответ** Конструктор похож на метод, но не является методом, он даже не считается членом класса. Поэтому его нельзя наследовать или переопределить в подклассе
**Источник** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

Какой тип возвращаемого конструктором значения?
**Ответ** Конструктор не имеет возвращаемого типа, им не может быть даже тип void, если возвращается тип void, то это уже не конструктор а метод, несмотря на совпадение с именем класса.
**Источник** https://javarush.ru/groups/posts/1391-konstruktorih-klassov-java-jdk-15

Дан класс.
```java
	class Null {
		//фрагмент 1
		Null Null() {
			return null;
		}
	}
```
	В каком фрагменте ошибка компиляции? 
	Удалите этот фрагмент полностью. 
	Прокомментируйте оставшийся фрагмент и продемонстрируйте функционал класса.
**Ответ** В оставшемся фрагменте создается метод Null с типом Null и возвращает объект null.

Если метод имеет то же имя, как и класс, то каким образом транслятор определяет где метод, а где конструктор (см. пример выше)?
**Ответ** Если метод имеет то же имя, что и класс, он должен иметь возвращаемый тип. В противном случае, это конструктор.
**Источник** https://askdev.ru/q/metody-vs-konstruktory-v-java-186541/

Дан класс.
```java
	class Name {
		String name;
		Name() {
			this(makeRandomName());
		}
		Name(String name) {
			super();
			this.name = name;
		}
		String makeRandomName() {
			int k = (int) (Math.random() * 3);
			String name = new String[] {"Alpha", "Beta", "Gamma"}[k];
			return name;
		}
		public String toString() {
			return name;
		}
		public static void main(String[] args) {
			System.out.println(new Name());
		}
	}
```
	Объясните причину ошибки компиляции. 
	Предложите минимум 2 способа исправления ошибки, использовать метод makeRandomName() обязательно.
**Ответ** Ошибка возникает из-за того что, до того как отработал конструктор по умолчанию - объект еще не создан. Соответственно нельзя получить значения полей не существующего объекта.
```java
	//вариант1
	String name = makeRandomName();
	Name() {
	}
	Name(String name) {
		super();
		this.name = name;
	}
	//вариант2
	  String name;
	  Name() {
	  	this.name=makeRandomName();
	  }
	  Name(String name) {
	  	super();
	  	this.name = name;
	  }
```

Дан класс.
```java
	class Int {
		int i;
		void inc(Int param) {
			//param = new Int();
			param.i++;
		}
		public static void main(String[] args) {
			Int obj = new Int();
			obj.inc(obj);
			System.out.println(obj.i);
		}
	}
```
	Изменится ли результат, если убрать комментарий?
	Объясните, почему?
**Ответ** Нет не изменится, потому что комппилятор java не компилирует комментарии

В чем смысл конструкции this?
	Перечислите случаи, когда используется конструкция this.
	В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими возможностями. Если можно, то каким образом?
**Ответ** Кроме данных и методов каждый экземпляр класса (объект) имеет неявную
	ссылку this на себя, которая передается также неявно и нестатическим методам
	класса. После этого каждый метод «знает», какой объект его вызвал. Вместо
	обращения к атрибуту id в методах можно писать this.id, хотя и не обязательно,
	так как записи id и this.id равносильны. Но если в методе объявлена локальная
	переменная или параметр метода с таким же именем, как и поле класса, то для
	обращения к полю класса использование this обязательно. Без использования
	указателя обращение всегда будет производиться к локальной переменной, так
	как просто не существует другого способа ее идентификации.
**Источник** И. Блинов с 58. Если можно, то каким образом?

Можно ли присвоить null ссылочной переменной this?
	Перечислите случаи, когда используется статический блок?
	В каких случаях можно обойтись без него. Если можно, то каким образом?
**Ответ** Логические блоки вызываются при каждом создании экземпляра класса. Его можно использовать для инициализации переменных, а также для вывода в консоль или же вызова методов.
**Источник** И. Блинов с 65-66.

Перечислите случаи, когда используется логический блок? В каких случаях можно обойтись без него. Если можно, то каким образом?  
**Ответ** Логические блоки вызываются при каждом создании экземпляра класса. Его можно использовать для инициализации переменных, а также для вывода в консоль или же вызова методов.  
**Источник** И. Блинов с 65-66.  
	
Что входит в сигнатуру метода?  
**Ответ.** В сигнатуру метода входит имя метода, а также передаваемые параметры.
**Источник.** https://javarush.ru/groups/posts/1942-signatura-metoda

Что значит ключевое слово native?  
**Ответ.** Приложение на языке Java может вызывать методы, написанные на языке
С++. Такие методы объявляются с ключевым словом native, которое сообщает
компилятору, что метод реализован в другом месте.  
**Источник**. И. Блинов с 64

Дан код.
```java
	public class BusinessTrip {
 	 …
  	public String bynToStr(int value) {
    	return (value / 100) + "." + (value / 10 % 10) + (value % 10);
 	 }
	}
```
Есть ли в нем семантическая ошибка?
Если да, то обоснуйте.  
**Ответ.** Данный метод не использует поля класса, поэтому его надо вынести в утилитный класс и объявить его как static

Дан код.
```java
	public class Utility {
  	private Utility() {
  	}
  	public String bynToStr(int value) {
    	return (value / 100) + "." + (value / 10 % 10) + (value % 10);
  	}
	}
```
Есть ли в нем семантическая ошибка?
Если да, то предложите альтернативные варианты.   
**Ответ.** Метод bynToStr нельзя будет вызвать, так как конструктор класса приватный. Можно сделать этот метод статическим.  

К каким данным можно обратиться в статическом методе?  
**Ответ.** Статический метод не может обратиться к нестатическим данным.  
**Источник.** И. Блинов с 61-62.  

Почему нельзя объявить статическое поле внутри метода?  
**Ответ**. Потому что статическое поле должно принадлежать именно классу, а не методу.  
**Источник.** И. Блинов с 61-62.  

Перечислите, какой код в классе можно выполнить до создания объекта.  
**Ответ**. Можно выполнить код, содержащийся в блоках.  
**Источник**. И. Блинов с 65-66.

В чем различие между объектом и экземпляром класса?  
**Ответ** Это одно и тоже понятие.  
**Источник** https://ru.stackoverflow.com/questions/519461/Какая-разница-между-экземпляром-и-объектом-класса.  

Назовите три этапа создания экземпляра класса.  
**Ответ**  
	1. Выделение памяти.  
	2. Создание ссылки.  
	3. Инициализация переменных и вызов конструктора.  
**Источник** https://javarush.ru/groups/posts/2137-porjadok-deystviy-pri-sozdanii-obhhekta
	   
Охарактеризуйте отношение композиции между классами? Как оно реализуется?   
**Ответ.** Композиция позволяет привязать один класс к другому. Её можно реализовать, указав в конструкторе одного класса другой класс.

Допустим, необходимо, чтобы метод возвращал два значения одного примитивного типа.
Предложите способы и подтвердите примерами.
**Ответ.**    
Способ 1 - создать массив
```java
        public int[] something(){
            int number1 = 1;
            int number2 = 2;
            return new int[] {number1, number2};
        }
```
Способ 2 - создать класс с двумя полями примитивного типа
```
        public static MyResult something() {
            int number1 = 1;
            int number2 = 2;
            return new MyResult(number1, number2);
        }

```
    
Допустим, необходимо, чтобы метод возвращал два значения разных примитивных типов.
Предложите способы и подтвердите примерами.
**Ответ.**  
Способ 1 - создать массив с типом Object
```java
        public Object[] something(){
            int number1 = 1;
            double number2 = 2.6;
            return new Object []{number1, number2};
        }
```
Способ 2 - создать класс с двумя полями разных примитивных типов
```java
            public static MyResult something() {
                int number1 = 1;
                int number2 = 2;
                return new MyResult(number1, number2);
            }
 
```
	
Что такое иммутабельный объект? 
Опишите 2 способа создания иммутабельных объектов. 
Подсказка. Способ 1 - класс материала в classes2. 
Какой альтернативный? 
Подсказка - ключевое слово final для полей не использовать.
Создайте иммутабельный класс для вещества по альтернативному способу.  
**Ответ.** Иммутабельный объект - это объект чьё состояние  после создания нельзя изменить.  
Способ 1  
    1.Не создавать методы «установки» - методы, которые изменяют поля или объекты, на которые ссылаются поля.  
    2.Сделать все поля final и private  
    3.Сделать класс final  
Способ 2  
1.Не создавать методы «установки» - методы, которые изменяют поля или объекты, на которые ссылаются поля.  
2.Сделать все поля private и final   
3.Сделать privat конструтор и метод для создания объектов  
***Источник.*** https://docs.oracle.com/javase/tutorial/essential/concurrency/immutable.html

Даны 2 класса.
``` java
        final class Material {
		private final String name;
		private final double density;
		...
	}
	class Runner {
		private static void printMaterial(final Material material) {
       		 	System.out.println(material);
		}
		public static void main(String[] args) {
        		Material steel = new Material("steel",7850);
        		printMaterial(steel);
		}
	}
```
В методе printMaterial() по ссылке material создается новый объект или имеется доступ к объекту new Material("steel",7850)? 
Какой пример можно использовать для обоснования ответа?  
**Ответ.** В методе printMaterial() по ссылке material имеется доступ new Material("steel",7850)
``` java
        final class Material {
		private final String name;
		private final double density;
		...
	}
	class Runner {
		private static void printMaterial(final Material material) {
       		 	System.out.println(material);
		}
		public static void main(String[] args) {
        		Material steel = new Material("steel",7850);
        		printMaterial(steel); // Вывод - Material@16d3586 
                System.out.println(steel); // Вывод -  Material@16d3586
		}
	}
```

Класс для комплексного числа содержит два поля:
```java	
	class Complex {
		private double re;
		private double im;
		…
	}
```
Реализуйте в данном классе методы: plus() для операции + и add() для +=.
Приведите пример использования каждого метода.
Реализуйте эти же методы при условии, что класс Complex является иммутабельным. 
***Ответ***
```java
class Complex {
    private double re;
    private double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public Complex plus (Complex c)
    {
        return new Complex (re + c.re, im + c.im);
    }

    public Complex add (Complex c)
    {
        re += c.re;
        im += c.im;
        return this;
    }
}
```

```java
final class Complex {
    private final double re;
    private final double im;

    public Complex(double re, double im) {
        this.re = re;
        this.im = im;
    }

    public Complex plus (Complex c)
    {
        return new Complex (re + c.re, im + c.im);
    }

    public Complex add (Complex c)
    {
        return new Complex(re + re + c.re, im + im + c.im);
    }
}
```

Для чего предназначен метод toString()?
В каких случаях он вызывается?  
**Ответ.** Возвращает представление объекта в виде строки. Метод вызывается автоматически, когда объект выводится методами println(), print() и некоторыми другими.                                                            
**Источник.** И.Блинов стр.112,113

Как реализован метод toString() в классе Object?  
**Ответ.** Метод toString() класса Object возвращает строку с описанием объекта в виде: getClass().getName() + '@' + Integer.toHexString(hashCode())
**Источник.** И.Блинов стр.113

Для чего предназначен метод equals()?
В каких случаях он вызывается?   
**Ответ.** Предназначен для использования и переопределения в подклассах с выполнением общих соглашений о сравнении содержимого двух объектов одного и того же типа. Автоматически вызывается при сравнении объектов в коллекции.  
**Источник.** И.Блинов стр.113
	
Как реализован метод equals() в классе Object?  
**Ответ.** Реализация метода в классе Object возвращает истину только в том случае, если обе ссылки указывают на один и тот же объект, а конкретно:
```java
 public boolean equals(Object obj) {
            return (this == obj);
            }
```          
**Источник.** И.Блинов стр.113

В чем различие между методом equals() и операции ==?
В каких случаях применение метода equals() и операции == эквивалентно?  
**Ответ.** Операция == сравнивает адреса ссылок на объект, а equals() сравнивает содержимое объектов.
Применение метода equals() и операции == эквивалентно в случае если у двух объектов одинаковый адрес в памяти.  
**Источник.** И.Блинов стр.113

Eclipse в стандартной конфигурации генерирует начало метода equals() следующим образом:
```java
    public boolean equals(Object obj) {
    if (this == obj)
    return true;
    if (obj == null)
    return false;
```
С чем связаны данные проверки, которые кажутся лишними?  
**Ответ** 
```java
	  if (this == obj) - проверяется находятся ли два объекта по одному и тому же адресу в памяти  
          if (obj == null) - проверяется не равняется ли null сравниваемый объект
```
**Источник** И.Блинов стр.113

Что такое garbage collection?
**Ответ:** Низкоприоритетный процесс, который запускается периодически и освобождает память,
использованную ненужными более объектами.
**Источник:** http://java-online.ru/garbage-collection.xhtml
    
Перечислите случаи, когда JVM отдает управление на garbage collector.
**Ответ:** JVM обычно запускает сборщик мусора при низком уровне свободной памяти.
Если памяти недостаточно даже после восстановления, JVM генерирует исключение OutOfMemoryError
**Источник:** https://javarush.ru/groups/posts/917-sborka-musora
    
Как сделать так, чтобы JVM сразу перешла в режим сборки мусора?
**Ответ:** Данный код запрашивает запуск GC:
```java
        System.gc()
        Runtime.getRuntime().gc()
```
**Источник:** https://javarush.ru/groups/posts/917-sborka-musora
    
Гарантирует ли garbage collector, что приложение в любом случае не будет иметь проблемы с недостатком памяти? 
Обоснуйте ответ.
**Ответ:** Не гарантирует, т.к. из-за ошибок в коде могут быть медленные утечки памяти.Также ошибки могут
возникать из-за операций,которые требуют различного объема памяти(большего, чем доступной) для вычислений.
**Источник:** https://overcoder.net/q/405670/java-garbage-collector-%D0%BD%D0%B5-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE-%D1%87%D0%B5%D1%80%D0%B5%D0%B7-%D1%80%D0%B5%D0%B3%D1%83%D0%BB%D1%8F%D1%80%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%BE%D0%BC%D0%B5%D0%B6%D1%83%D1%82%D0%BA%D0%B8-%D0%B2%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%B8
    
Для чего предназначен метод finalize()?
Какой недостаток у метода?
**Ответ:** Данный метод предназначен для автоматического освобождения системных ресурсов, занимаемых объектом,
на котором будет метод вызван.
Недостатком является то,что при вызове finalize() вы заставите JVM удерживать все другие объекты,
на которые ссылается финализуемый объект.Также данный метод может и не вызываться GC
**Источник:** https://coderoad.ru/9556827/%D0%9A%D0%B0%D0%BA-finalize-%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D0%B5%D1%82-%D0%B2-java
    
Для чего предназначены оболочечные классы?
Как они называются на инглише?
**Ответ:**   Оболоченные классы, или " class wrappers", предназначены для добавления новых возможностей
работы с привычными типами
**Источник:** https://vertex-academy.com/tutorials/ru/klassy-obolochki-v-java/
    
В чем преимущество примитивных типов перед соответствующими оболочечными классами?
**Ответ:** Переменные примитивных типов хранятся в стеке, в то время как ссылочные типы ссылаются
на объекты в куче,отсюда и разница в скорости доступа и расхода памяти
**Источник:** https://topjava.ru/blog/primitives-and-referenses
     
Что такое autoboxing и unboxing?
**Ответ:** Autoboxing - преобразования примитивных типов в эквивалентные объекты.
Unboxing - процесс преобразования объектов в соответствующие им примитивные типы
**Источник:** https://javarush.ru/groups/posts/706-avtoupakovka-i-raspakovka-v-java

Дан код:
	Integer a = 3, b =7;
	Long c = a + b;
	Перечислите все операции, где задействованы autoboxing и unboxing.
**Ответ:** Integer a = 3, b =7; - задействован autoboxing.
	Long c = a + b - сначала unboxing в момент суммирования, затем autoboxing в момент присваивания
	
Дан корректный раннер-класс. 
	Будет ли ошибка компиляции, если удалить модификатор static из сигнатуры метода main()? 
	Обоснуйте ответ.
	Что произойдет, если отправить на выполнение измененный класс?
**Ответ:** Будет ошибка компиляции,т.к. не будет точки входа в программу
**Источник:**   http://zonakoda.ru/vsyo-o-metode-main.html

Дан класс.
```java
	class Runner {
		public static void main(String[] args) {
        		System.out.println("Hello, world!");
		}
	}
```
	Запрещается изменять синий код, т.е. метод main().
	Добавить код в класс Runner, так чтобы в результате запуска этого класса из под JVM в консоли был следующий результат:
	I am java.
	Hello, world!
**Ответ:** 
```java
    public class Runner {
        public static void main(String[] args) {
            System.out.println("Hello, world!");
        }
        static {
            System.out.println("I am java.");
        }
    }
```
