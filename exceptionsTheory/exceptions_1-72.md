**Вопрос.** Что такое исключения?  
**Ответ.** Исключительные ситуации (исключения) и ошибки возникают во время выполнения программы, когда появившаяся проблема не может быть решена в текущем контексте и невозможно продолжение работы программы.  
**Источник.** И. Блинов. Стр 264.

**Вопрос.** Какие действия производит система времени выполнения при возникновении исключения?  
**Ответ.** При возникновении исключения в приложении создается объект, описывающий это исключение. Затем текущий ход выполнения приложения останавливается, и включается механизм 
обработки исключений. При этом ссылка на объект-исключение передается обработчику исключений, который пытается решить возникшую проблему и продолжить выполнение программы. Если в классе используется метод, в котором 
может возникнуть проверяемая исключительная ситуация, но не предусмотрена 
ее обработка, то ошибка возникает еще на этапе компиляции. При создании такого метода программист обязан включить в код метода обработку исключений, 
которые могут генерироваться в этом методе, или передать обработку исключения на более высокий уровень методу, вызвавшему данный метод. Схема обработки исключения подобна схеме обработки событий  
**Источник.** И. Блинов. Стр 264.

**Вопрос.** Как называется блок кода, который обрабатывает исключение?  
**Ответ.** Блок catch.  
**Источник.** И. Блинов. Стр 268.

**Вопрос.** Как реализуется требование «Поймай или Укажи» (Catch or Specify)?  
**Ответ.** Код, который может выдавать определенное исключение, должен:
либо быть заключен в блок try с дальнейшей обработкой исключения,
либо метод, который выдает исключение, должен содержать throws-объявление, в котором перечислены исключения.
Код, не удовлетворяющий требованиям «Поймай или Укажи», не будет компилироваться.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/catchOrDeclare.html

**Вопрос.** Какая иерархия классов исключений?  
**Ответ.** Все исключения являются наследниками суперкласса 
Throwable и его подклассов Error и Exception
из пакета java.lang.  
**Источник.** И. Блинов. Стр 265.

**Вопрос.** Какие виды исключений относятся к непроверяемым?  
**Ответ.** Класс RuntimeException и порожденные от него классы относятся к непроверяемым исключениям.
**Источник.** И. Блинов. Стр 265.

**Вопрос.** Какие компоненты могут входить в обработчик исключений?  
**Ответ.** перехватить, указать, проверенные исключения, исключения, которые могут быть выброшены в рамках метода.  
**Источник.** http://journals.ecs.soton.ac.uk/java/tutorial/java/exceptions/catchOrDeclare.html

**Вопрос.** Для каких ситуаций используется оператор try-with-resources?  
**Ответ.** Оператор try-with-resources особенно подходит для ситуаций, которые используют Closeable ресурсы, 
такие как потоки. В случае исключения данный оператор гарантированно и автоматически закроет все потоки.  
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/handling.html

**Вопрос.** Какой код заключается в блок try?  
**Ответ.** Ожидание возникновения исключения.  
**Источник.** И. Блинов. Стр 268.

**Вопрос.** Выполняется ли весь код блока try в случае возникновения исключения?  
**Ответ.** Нет.  

**Вопрос.** Может ли использоваться только один блок try (без catch или finally)?  
**Ответ.** Нет.

**Вопрос.** Какое назначение блока catch?  
**Ответ.** Перехват и обработка исключения.  
**Источник.** И. Блинов. Стр 268.

**Вопрос.** Сколько блоков catch может содержаться после try-оператора?  
**Ответ.** Если в блоке try может быть сгенерировано в разных участках кода несколько типов исключений, то необходимо наличие нескольких блоков catch, если 
только блок catch не обрабатывает все типы исключений.  
**Источник.** И. Блинов. Стр 269.	

**Вопрос.** Если применяется несколько блоков catch, то в каком порядке в случае возникновения исключения они вызываются?  
**Ответ.** Подклассы исключений в блоках catch должны следовать перед любым 
из их суперклассов, иначе суперкласс будет перехватывать эти исключения.  
**Источник.** И. Блинов. Стр 270.

**Вопрос.** Какой код может быть между блоками try и catch?  
**Ответ.** Нельзя поместить код между блоками try и catch.  

**Вопрос.** Может ли использоваться блок catch без блока try?  
**Ответ.** Нет,не может.  

**Вопрос.** Сколько типов исключений может обрабатывать один блок catch?  
**Ответ.** Один тип - checked, т.е. проверяемые исключения.  

**Вопрос.** В случае отсутствия исключения в блоке try выполняется ли блок catch?  
**Ответ.** Нет,не выполняется.  

**Вопрос.** Для чего используется блок finally?  
**Ответ.**  Для освобождения ресурсов, захваченных программой.  

**Вопрос.** В случае отсутствия исключения в блоке try выполняется ли блок finally (при его наличии)?  
**Ответ.** Да,код в блоке finally обязательно выполняется после инструкция try или catch.  
**Источник.** Блинов стр.211  

**Вопрос.** Могут ли использоваться блоки try-finally без блока catch?  
**Ответ.**  Могут.  

**Вопрос.** Приведите пример кода, в котором используется оператор try-with-resources.  
**Ответ.**
~~~java
public static String readLineFromFile(String path)
        throws IOException {
    try (FileReader f = new FileReader("a.txt");
         BufferedReader br = new BufferedReader(f)) {
        return br.readLine();
    }
}
~~~  

**Вопрос.** Какой оператор может использоваться вместо try-with-resources?  
**Ответ.** try-catch-finally.  

**Вопрос.** Может ли применяться оператор try-with-resources совместно с блоком finally?  
**Ответ.** Может.  

**Вопрос.** Какое ключевое слово используется в сигнатуре метода, чтобы указать на возможность выбрасывания им исключения?  
**Ответ.** throws.  

**Вопрос.** Сколько исключений может выбрасывать метод?  
**Ответ.** Метод может декларировать любое количестко исключений.  
**Источник.** http://skipy.ru/technics/exceptions.html#exc

**Вопрос.** Какое ключевое слово используется для гарантированного выбрасывания исключения?  
**Ответ.** throw.  

**Вопрос.** Можно ли создавать свои собственные классы исключений?  
**Ответ.** Да,с помощью наследования,например от класса Exception.  

**Вопрос.** Приведите примеры наиболее известных подклассов класса Exception.  
**Ответ.** 
1. RuntimeException - базовый класс для так называемой группы непроверяемых исключений; 
2. IOException - базовый класс для исключений с прерванными операциями ввода-вывода; 
3. ClassNotFoundException - JVM пытается загрузить определенный класс и не обнаруживает такого же в classpath;
4. NoSuchMethodException - Вызов несуществующего метода.
5. IllegalAccessException - Вызывается когда приложение пытается отражающим образом создать экземпляр (кроме массива), установить или получить поле, или вызвать метод, но у в настоящий момент выполняющегося метода нет доступа к определению указанного класса, поля, метода или конструктора.

**Вопрос.** Приведите примеры наиболее известных подклассов класса RuntimeException.  
**Ответ.**  
1.ArithmeticException - Арифметическая ошибка: деление нануль и др.;  
2.ArrayIndexOutOfBoundsException - Индекс массива находится вне границ;  
3.ClassCastException - Недопустимое приведение типов;  
4.ArrayStoreException - Назначение элементу массива несовместимого типа;  
5.IndexOutOfBoundsException - Некоторый тип индекса находится вне границ;  
6.NullPointerException - Недопустимое использование нулевой ссылки;  

**Вопрос.** Что такое сцепление исключений?  
**Ответ.** Это позволяет к одному исключению "прикрепить" другое, которое будет описывать причину появления 1-ого исключения.  

**Вопрос.** Приведите пример кода со сцеплением исключений.  
**Ответ.**
~~~java
public class WrongNumberException{
    public  WrongNumberException(Throwable illegalArgument){
        super(illegalArgument);
    }
}

...
try{
    int x = 5 / 0;
}
catch(IllegalAgrumentException e){
    throw new WrongNumberException(e);
}
~~~  
**Вопрос.** Какая информация приводится при трассировке стека во время исключения?  
**Ответ.** Трассировка стека выводит информацию о методах, которые были вызваны до исключения.

**Вопрос.** В каких случаях целесообразно создавать собственный класс исключения?  
**Ответ.** При обработке ситуации, не являющейся исключением с точки зрения языка, но нарушающей логику вещей.  
**Источник.** И. Блинов. Стр 212.

**Вопрос.** Какой класс исключений может использоваться в качестве суперкласса для собственного исключения?  
**Ответ.** Класс Exception.  
**Источник.** И. Блинов. Стр 212.

**Вопрос.** Какие исключения целесообразно делать проверяемыми, а какие – непроверяемыми?  
**Ответ.** Проверяемые исключения для ситуаций, когда есть основания полагать, что вызывающий код способен выполнить восстановление. Непроверяемые для указания на программные ошибки.  
**Источник.** Д. Блох. Стр 362-363


**Вопрос.** Какие преимущества в механизме выбрасывания и обработки исключений?  
**Ответ.** Исключение можно выбросить в методе, который вызывает в блоке try.

**Вопрос.** Можно ли выбрасывать исключения в конструкторах?  
**Ответ.** Да, можно.

**Вопрос.** Может ли произойти потеря исключения? Если да – приведите пример.  
**Ответ.** Да, может
~~~java
int x = 0;
try{
    int y = 5 / x
}
catch(IllegalArgumentException e){
    ...
}
finaly{
   ... 
}
~~~

**Вопрос.** Обладают ли исключения свойством транзакционности?  
**Ответ.**

**Вопрос.** Является ли данный код антипаттерном?
    Обоснуйте ответ.
~~~java
    void methodCatchesSomeException() {
    ...
    try {
    ...
    } catch (SomeException ex) {
    ...
    }
    ...
    }
~~~
**Ответ.** Нет, все хорошо.

**Вопрос.** Является ли данный код антипаттерном?
    Обоснуйте ответ.
~~~java
    void methodThrowsSomeCheckedException() {
    ...
    throw new SomeCheckedException();
    ...
    }
~~~
**Ответ.** Да, нет условия, при котором будет выброшено исключение.

**Вопрос.** Является ли данный код верным? Укажите почему.
~~~java
    void methodThrowsSomeCheckedException() throws SomeCheckedException {
    ...
    throw new SomeCheckedException();
    ...
    }
~~~
**Ответ.** Нет, так как throws после сигнатуры метода пишется только для непроверяемых исключений.

**Вопрос.** Приведите примеры кода с выбросом RuntimeException явным образом и в случае программной ошибки.  
**Ответ.**
Явные образом
~~~java
int x = 0;
try{
    int y = 5 / x
}
    catch(IllegalArgumentException e){
    ...
}
~~~
Случай программной ошибки.
~~~java
int x = 0;
int y = 5 / x
~~~

**Вопрос.** Можно ли отрефакторить данный код? Если да, то выполните.  
~~~java
void methodThrowsSomeRuntimeException() {
            ...
            throw new SomeRuntimeException();
            ...
}
~~~  
**Ответ.** При генерации исключения, ему не передается никаких данных.  
~~~java
void methodThrowsSomeRuntimeException() {
            ...
            throw new SomeRuntimeException(...);
            ...
~~~  
**Источник.** Блох глава 10.7.Включайте в сообщения информацию о сбое  

**Вопрос.** Является ли данный код антипаттерном? 
Обоснуйте ответ. 
~~~java
void methodThrowsSomeRuntimeException() throws SomeRuntimeException {
            ...
            throw new SomeRuntimeException(...);
            ...
}
~~~  
 **Ответ.** Да. Исключения типа java.lang.RuntimeException, и его наследники, не декларируются. 
 Компилятор это допускает, соответственно, позволяя их не обрабатывать. 
 Более того, ловить java.lang.RuntimeException – дурной тон, ибо вместо того, чтобы устранять причину, мы нейстрализуем последствия.    
**Источник.** http://www.skipy.ru/technics/exceptions.html  И.Блинов с.219  

**Вопрос.** В какой версии Java появился оператор try-with-resources? Приведите пример кода с использованием указанного оператора.  
**Ответ.** Java SE 7  
~~~java
 static String readFirstLineFromFile(String path) throws IOException {
    try (BufferedReader br =
                   new BufferedReader(new FileReader(path))) {
        return br.readLine();
    }
}  
~~~
 **Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  
 
**Вопрос.** Является ли данный код антипаттерном? 
Обоснуйте ответ.  
~~~java
void methodWithAutocloseableInstance() {
            ...
            try(SomeResource res = new SomeResource(...)) {
                        ...
            }
            ...
}  
~~~  
**Ответ.** Нет, так как все потоки открытые таким образом автоматически закрывабтся при выходе из try.    
**Источник.** https://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html  

**Вопрос.** Является ли данный код антипаттерном? 
Обоснуйте ответ.  
~~~java
void methodWithAutocloseableInstance() {
            ...
            try(SomeResource res = new SomeResource(...)) {
                        ...
            } catch (CorrectCheckedException ex) {
                        …
            }
            ...
}
~~~  
 **Ответ** Нет. В теле метода может возникнуть исключительная ситуация CorrectCheckedException, которая будет обработана в catch.  
 
**Вопрос.** Является ли данный код антипаттерном? 
Обоснуйте ответ.  
~~~java
try {
           …
}  catch (SomeException е) {
            //no code
}
~~~  
**Ответ.** Да, так как исключение игнорируется. 
При генерации и перехвате исключения никто не узнает, что исключительная ситуация имела место,
и не станет устранять ее причины.  
**Источник.** И.Блинов с.218

**Вопрос.** Является ли данный код антипаттерном? 
Обоснуйте ответ.  
~~~java
try {
            …
}  catch (SomeException е) {
            System.out.println(“Something went wrong!”);
}
~~~  
**Ответ.** Да, потому что ошибка выводится в консоль, но может возникать у пользователя при работе с приложением.  
**Источник.** И. Блинов глава 8  
 
**Вопрос.** Является ли данный код антипаттерном, если блок catch находится не в конце раннер-метода main()? 
Обоснуйте ответ.  
~~~java
try {
            …
}  catch (Exception е) {
            …
}
…
~~~  
или другой вариант
 ~~~java
try {
            …
}  catch (Throwable е) {
            …
}
…
~~~  
**Ответ.** Для обоих вариантов да. Потому что отлавливается обобщенное исключение. Лучше использовать более конкретное.  
**Источник.** И.Блинов с.218

**Вопрос.** Является ли данный код антипаттерном? 
Обоснуйте ответ. 
~~~java
try {
        int i = 0;
        while(true) {
            а[i++].f();
        }
} catch(ArraylndexOutOfBoundsException е) {
        …
}
~~~  
**Ответ.** Да, потому что данное исключение является наследником RuntimeExeption и должно обрабатываться программистом при написании кода.  
 
**Вопрос.** Есть ли недостатки у API  написанного только с использованием обрабатываемых исключений?  
**Ответ.** Да, отлавливание каждого исключения довольно ресурсоемкий процесс. 
Если невозможно восстановить работу программы после отлова исключения, лучше использовать непроверяемые исключения.  
**Источник** Блох глава 10.3.Избегайте ненужных проверяемых исключений    
  
**Вопрос.** Даны два варианта сеттера.  
Какой является более предпочтительным в использовании?  
Обоснуйте ответ.  
Вариант 1.  
~~~java
void setPositiveValue(int value) {
            if(value <= 0) {
                        throw new IllegalArgumentException(...);
            }
            this.value = value;
}
~~~  
Вариант 2.  
~~~java
void setPositiveValue(int value) throws SomeCheckedException {
            if(value <= 0) {
                        throw new SomeCheckedException(...);
            }
            this.value = value;
}
~~~
 **Ответ.** Вариант 1 Потому что если возможно использовать стандартное исключение - стоит так и делать.  
 **Источник** Блох глава 10.4 Предпочитайте использовать стандартные исключения  
  И.Блинов с.218-219  
 
**Вопрос.** Приведите пример наиболее распространенных из повторно используемых исключений и причины их применения.  
**Ответ.**  
IllegalArgumentException  - Неверное ненулевое значение параметра  
IllegalStateException - Неверное состояние объекта для вызова метода  
NullPointerException - Неразрешенное нулевое значение параметра  
IndexOutOfBoundsException - Индексный параметр за границей допустимого диапазона  
ConcurrentModificationException - Обнаружено запрещенное параллельное изменение объекта  
UnsupportedOperationException - Объект не поддерживает метод  
**Источник** Блох глава 10.4 Предпочитайте использовать стандартные исключения  

**Вопрос.** Если недостаточно информации для принятия решения и...  
1)    исключительная ситуация должна быть исправлена на ближайшем уровне;  
2)    исключительная ситуация маловероятна  
Экземпляры подклассов каких типов исключений целесообразно сгенерировать в каждом случае?  

**Ответ.**   
1) Использовать экземпляр проверяемого исключения подкласса Exeption, который обрабатывается в этом же методе.  
Предоставляя пользователю проверяемое исключение, разработчик API передает ему право 
осуществить восстановление из соответствующей ситуации.  
2) Если исключение маловероятно лучше вообще его не вызывать, а написать условие для проверки. Экземпляр подкласса RuntimeException.    
 
**Вопрос.** Выделите в блоке try-catch основной и альтернативный сценарии. 
Обоснуйте ответ.  
~~~java
try {
            ...
            User user = source.getUser(login, password);
            if(GUEST_USER.equals(user) {
                        …
            } else {
                        …
            }
            ...
}  catch (SourceException е) {
            …
}
class Source {
            public User getUser(String login, String password) throws SourceException {
                        ...
                        throw new SourceException(...);
                        ...
                        return GUEST_USER;    //wrong login or password
                        ...
                        return new User(...);
            }
            ...
}
~~~
 **Ответ.**
Если не будет условия проброса исключения в методе getUser, отработает код до throw, а затем в любом случае выбросится исключение SourceException, которое будет обработано в catch, а код написанный после проигнорируется.  

**Вопрос** Перепишите код предыдущего задания с условием, что ввод неправильных логина или пароля является альтернативным сценарием.  
**Ответ**
```java

```

**Вопрос:** Что такое трансляция исключения, когда ее используют и какие правила ее использования? Приведите пример трансляции исключения.  
**Ответ:** Трансляция исключения - верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня.
Ее используют если метод инициирует исключение, не имеющее видимой связи с решаемой задачей. Это происходит, когда метод передает дальше исключение, инициированное абстракцией более низкого уровня.
Это засоряет API верхнего уровня деталями реализации. Если в следующей версии реализация
верхнего уровня поменяется, то могут поменяться и инициируемые им исключения, в результате чего могут перестать работать имеющиеся клиентские программы.
```java
try {
    ... // Применение низкоуровневой абстракции
    }
    catch (LowerLevelException е)
        {
            throw new HigherLevelException(...);
        }
```  
**Источник:** Дж.Блох Стр.371

**Вопрос:** Как можно избежать использования трансляций и зачем нужно это предпринимать?  
**Ответ:** Наилучший способ обработки исключений нижнего уровня — полное исключение их возможности путем обеспечения гарантированной успешности
вызова метода нижнего уровня. Иногда этого можно добиться путем проверки
корректности аргументов метода верхнего уровня перед их передачей на нижний уровень.
Если предупредить появление исключений на нижних уровнях невозможно,
то лучшее решение состоит в том, чтобы верхний уровень молча обрабатывал
эти исключения, изолируя клиента от проблем нижнего уровня. В таких условиях чаще всего достаточно протоколировать исключения, используя соответствующий механизм регистрации, такой, например, как java.util. logging.
Это позволяет программисту изучить проблему и в то же время изолирует от нее клиентский код и пользователей.  
**Источник:** Дж.Блох Стр.373

**Вопрос:** В каких случаях  надо предпочесть сцепление трансляции?  
**Ответ:** В тех случаях, когда исключение нижнего уровня может быть полезно для
анализа ситуации, вызвавшей исключение, лучше использовать особый вид
трансляции исключений, называемый цепочкой исключений.  
**Источник:** Дж.Блох Стр.372

**Вопрос:** Можно ли для исключительной ситуации определить, класс, который не является подклассом Exception, RuntimeException, Error.
Если да, то как он будет себя проявлять (как checked-exception или как unchecked-exception)?  
**Ответ:** Если класс не является подклассом Exceptions, то он будет unchecked если же класс не является подклассом RuntimeException или Error, то он будет checked.  
**Источник:** https://habr.com/ru/company/golovachcourses/blog/225585/

**Вопрос:** Обязательно ли информацию об исключительной ситуации представлять строковым полем?
Если нет, то какой альтернативный способ создания строкового представления исключения?  
**Ответ:** Не обязательно, с помощью конструкторов или другого исключения

**Вопрос:** Если метод завершается сбоем, что нужно сделать с объектом, на котором был вызван этот метод?  
**Ответ:** Оставлять проверяемый объект в том же состоянии, в каком тот был перед вызовом  
**Источник:** Дж.Блох Стр.378

**Вопрос:** Приведите способы достижения атомарности по отношению к сбоям.  
**Ответ:**
- Первый способ заключается в разработке неизменяемых объектов
- Второй способ заключается в достижении путем проверки правильности параметров перед выполнением операции
- Третий способ заключается в упорядочении вычислений таким образом, чтобы все части кода, способные повлечь сбой, предшествовали первой модификации объекта.
- Четвертый сбособ состоит в выполнении операции над временной копией объекта и замене содержимого объекта содержимым копии по завершении операции
- Пятый способ заключается в написании специального кода восстановления, который перехватывает
  сбой, возникающий в ходе выполнения операции, и заставляет объект вернуться в состояние, в котором он находился до начала операции  
  **Источник:** Дж.Блох Стр.378-379

**Вопрос:** Приведите пример, когда отсутствие транзакционности в исключениях, приводит к сохранению ссылки на объект в неверном состоянии.  
**Ответ:** Stack trace

**Вопрос:** Необходимо создать коллекцию из результатов тестов, находящихся в валидном файле src/in.csv.
Пример файла
```csv
cool;75;90
clever;68;95
looser;30;48
```
Является ли код, реализующий задание, антипаттерном?
Обоснуйте ответ.
```java
public class Runner {
        	public static void main(String[] args) {
                    	List<Trial> trials = new ArrayList<Trial>();
                    	try(Scanner sc = new Scanner(new FileReader("src/in.csv"))) {
                               	while(sc.hasNext()) {
                                           	Trial trial = getTrial(sc);
                                           	trials.add(trial);
                               	}
                               	printTrials(trials);
                    	} catch (FileNotFoundException e) {
                               	System.out.println(Constants.ERROR_FILE_FOUND);
                    	}
        	}
        	private static Trial getTrial(Scanner sc) {
                    	String csvLine = sc.nextLine();
                    	String[] values = csvLine.split(Constants.DELIMETER);   	
                    	try {
                               	String name = values[Constants.NAME_INDEX];
                               	int mark1 = Integer.parseInt(values[Constants.MARK1_INDEX]);
                               	int mark2 = Integer.parseInt(values[Constants.MARK2_INDEX]);
                   		return new Trial(name, mark1, mark2);
                    	} catch (CsvLineException e) {
                               	System.out.println(Constants.ERROR_WRONG_DATA);
                    	}
        	}
```   
**Ответ:**

**Вопрос:** Приведите пример кода собственного исключения (реализация в одном классе всего нижеперечисленного). Класс исключения содержит:
-         поле, которым является неправильная строка, считанная из файла (имя csvLine);
-         конструктор по умолчанию, вызывающий конструктор суперкласса;
-         параметризованный конструктор, принимающий экземпляр исключения и неправильную строку, считанную из файла;
-         параметризованный конструктор, принимающий строку с указанием причины исключения и  неправильную строку, считанную из файла;
-         геттер с возвратом неправильной строки;
-         переопределенного метода toString с указанием неправильной строки и метода вывода сообщения об ошибки.  
**Ответ:**

**Вопрос:** Необходимо создать метод для экспорта csv-файла в коллекцию.
При наличии хотя бы одной ошибки в исходных данных “отменить” создание
коллекции.
Какие антипаттерны содержит следующий код?
Предложите варианты по избавлению от них.
```java
private static List<Trial> getTrials(Scanner sc) {
        List<Trial> trials = new ArrayList<Trial>();
        try {
        while(sc.hasNext()) {
        Trial trial = getTrial(sc);
        trials.add(trial);
        }
        } catch (CsvLineException e) {
        System.err.println(e);
        }
        return trials;
        }
```  
**Ответ:**

**Вопрос:** Создать метод для экспорта данных в коллекцию из последовательного источника экземпляров Trial.
Его необходимо дополнить, чтобы происходила обработка следующих исключительных ситуаций:
1. 	Файл не найден.
2. 	Ошибка в csv строке.
      Примечание: код не должен нарушать принцип “верхние уровни приложения должны перехватывать исключения нижних уровней и, в свою очередь, генерировать исключения, которые можно пояснить в терминах абстракции верхнего уровня”
```java
//начало кода, реализующего задание
//---
interface TrialProvidable {
    boolean hasTrial();
    Trial getTrial();
}

public class TrialCsvImpl implements TrialProvidable {
    private Scanner sc;
    public CsvImpl(String csvName) {
        sc = new Scanner(new FileReader(csvName));
    }
    public boolean hasTrial() {
        return sc.hasNextLine();
    }
    public Trial getTrial() {
// get Trial instance from csv line
        return trial;
    }
}

public class Runner {
    private static List<Trial> getTrials(TrialProvidable trialProvider) {
        List<Trial> trials = new ArrayList<Trial>();
        while(trialProvider.hasTrial()) {
            Trial trial = trialProvider.getTrial();
            trials.add(trial);
        }
        return trials;
    }

    public static void main(String[] args) {
        TrialProvidable trialProvider = null;
        try {
            if("csv".equals(args[0])) {
                trialProvider = new TrialCsvImpl("src/in.csv");
            } else {
                trialProvider = new TrialDBImpl();
            }
            List<Trial> trials = getTrials(trialProvider);
…
        } finally {
            if (trialProvider != null) {
                trialProvider.close();
            }
        }
    }
}
//---
//конец кода, реализующего задание
```  
**Ответ:** 