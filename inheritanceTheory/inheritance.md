Как по терминологии Java называются базовый класс и наследуемый класс?  
**Ответ.** Базовый класс - суперкласс, наследуемый класс - подкласс.  
**Источник.** И.Блинов Стр.97

Какой класс является родительским для всех классов?  
**Ответ.** класс Object  
**Источник.** И.Блинов Стр.97

Какой класс является родительским для всех перечислений?  
**Ответ.** Типобезопасные перечисления (typesafe enums) в Java представляют собой классы и являются подклассами абстрактного класса java.lang.Enum.  
**Источник.** И.Блинов Стр.76

Какой интерфейс является родительским для всех интерфейсов?  
**Ответ.** нет такого интерфейса  

Сформулируйте критерий отношения наследования между двумя сущности физического мира. 
Другими словами, какому условию должны удовлетворять две сущности физического мира, чтобы соответствующие им классы были связаны отношением наследования?  
**Ответ.** При построении иерархии наследования необходимо, чтобы отношение между классами можно выразить как «is-a», или «является».  
**Источник.** И.Блинов Стр.123

Есть ли отношение наследования между сущностями:
а) квадрат и прямоугольник; 
б) сосна и доска; 
в) книга и страница?
Поясните ответ.  
**Ответ.**  
а) да, квадрат является прямоугольгтком  
б) нет, сосна не является доской и наоборот  
в) нет, книга не является страницей и наоборот  

В jdk класс RuntimeException является подклассом Exception.
Есть ли нарушение критерия наследования?  
Поясните ответ.  
**Ответ.** Да, RuntimeException (unchecked), наследуется от класса Exception, который является (checked).  

В чем смысл конструкции super?
Перечислите случаи, когда используется конструкция super.
В каких случаях можно обойтись без неё, т.е. заменить другими синтаксическими
возможностями. Если можно, то каким образом?  
**Ответ.** super - предоставляет текущий экземпляр родительского класса. Ключевое слово super применяется для обращения к конструктору суперкласса и для доступа к полю или методу суперкласса. 
При созданиии конструктора без папрметров в подклассе, можно явно не вызывать super.
При обращении к членам суперкласса (методам и переменным) можно опустить super, если когда имена членов подкласса не скрывают члены суперкласса с такими же именами.  
**Источник.** И.Блинов Стр.102

Можно ли одновременно использовать this() и super() в конструкторе?  
**Ответ.** Нет не можем, потому что this() и super() являются вызовами конструктора. Так как вызов коструктора
должен быть всегда на первом месте, то они не могут вызываться оба.  
**Источник.** https://docs.oracle.com/javase/tutorial/java/javaOO/thiskey.html&prev=search&pto=aue
              https://docs.oracle.com/javase/tutorial/java/IandI/super.html&prev=search&pto=aue

Дан код.
```Java
class SomeClass() {

    public SomeClass() {
        doSmth();
    }
    
    protected void doSmth() {

}
}
```
Это потенциальный антипаттерн. Почему?  
**Ответ.** Метод является protected, не стоит его записывать в конcтруктор так как при наследовании, 
производный класс может переопределить поведение конструктора базового класса, что является опасным.  

Если класс реализует некоторый интерфейс, то необходимо ли в нем определить все методы, объявленные в интерфейсе?  
**Ответ.** Если класс, реализующий интерфейс, не является абстрактным, все методы интерфейса должны быть определены в классе.  
**Источник.** http://proglang.su/java/interfaces

Для каких целей необходим интерфейс, в котором не объявлено ни одного метода?  
**Ответ.** Интерфейс, который не содержит какого-либо метода для реализации, называется маркером или интерфейсами тегов.
Он предоставляет информацию о типе объектов во время выполнения , поэтому компилятор и JVM имеют  дополнительную информацию об объекте.
Интерфейс маркера также называется интерфейсом тегирования. Хотя интерфейсы маркеров все еще используются, они, скорее всего, 
указывают на запах кода, и их следует использовать с осторожностью. Основная причина этого в том, что они размывают границы того,
что представляет собой интерфейс, поскольку маркеры не определяют никакого поведения. Новые разработки предпочитают аннотации для 
решения некоторых из тех же проблем.  
**Источник.** https://www.baeldung.com/java-marker-interfaces

Можно ли переопределить метод в том же самом классе? Можно ли его перегрузить в этом классе?  
**Ответ.** Метод нельзя переопределить в том же самом классе, так как методы переопределяются только в подклассах.
Перегрузить метод в том же самом классе можно. Для этого мы определяем методы с одним и тем же именем, но с разными 
типами и/или количеством параметров.  
**Источник.** https://metanit.com/java/tutorial/2.18.php

Можно ли переопределить метод в подклассе? Можно ли его перегрузить в подклассе?  
**Ответ.** Метод в подклассе можно переопредлить. Для этого мы объявляем метод в подклассе с тем же именем и теми же 
параметрами, что и в суперклассе. Метод можно перегрузить в подклассе. Если два метода класса 
(оба объявлены в одном классе, или оба унаследованы классом, или один объявлен и один унаследован) 
имеют одно и то же имя, но сигнатуры, которые не эквивалентны переопределению, то имя метода называется перегруженным.  
**Источник.** https://docs.oracle.com/javase/specs/jls/se7/html/jls-8.html#jls-8.4.9 

Можно ли переопределить статический метод? Поясните ответ.  
**Ответ.** Нет нельзя. Если вы объявите такой же метод в классе-наследнике, т.е. метод с таким же именем 
и сигнатурой, вы лишь «спрячете» метод суперкласса вместо переопределения. Это явление известно как сокрытие 
методов (hiding methods). Это означает, что при обращении к статическому методу, который объявлен как в родительском,
так и в дочернем классе, во время компиляции всегда будет вызван метод исходя из типа переменной. В отличие от 
переопределения, такие методы не будут выполнены во время работы программы.  
**Источник.** https://javarush.ru/groups/posts/modifikator-static-java

Как запретить переопределение метода в подклассе? Назовите 2 способа.  
**Ответ** Это можно сделать при помощи модификаторов final и private.  
**Источник** И.Блинов Стр.100

С помощью какого механизма реализуется полиморфизм в Java?  
**Ответ** Переопределение методов является основой концепции динамического связывания, реализующей пилиморфизм.  
**Источник** И.Блинов Стр.103

Верно ли утверждение, что если есть ссылка на объект подкласса, то тем самым есть ссылка на объект суперкласса? Если да, то как ее получить?  
**Ответ** Да верно,  Третья форма специфична для Java и обеспечивает вызов из под класса переопределенного метода суперкласса, причем если в суперклассе этот
метод не определен, то будет осуществляться поиск по цепочке наследования
до тех пор, пока он не будет найден.  
**Источник** И.Блинов Стр.102

SmallEntity и BigEntity - это подклассы Entity.
Можно ли отрефакторить данный код? Если да, то выполните.  
```java
class EntityFactory {
    public static Entity getEntity(int num) {
        switch(num) {
            case 2: return new Entity();
            case 3: return new SmallEntity();
            case 4: return new BigEntity();
            default: throw new IllegalArgumentException();
        }
    }
}
```
**Ответ** да, можно  
```java
class EntityFactory {
    private Enum EntityKind{
        ENTITY{
            Entity getEntity(int num){
                return new Entity;
            }
        },
        SMALLENTITY{
            Entity getEntity(int num){
                return new SmallEntity;
            }
        },
        BIGENTITY{
            Entity getEntity(int num){
                return new BigEntity;
            }
        };
        abstract Entity getEntity(int num);
    }
    public static Entity getEntityFromFactory(int num) {
        EntityKind kind = EntityKind.valueOf(int num);
        return kind.getEntity(num);
    }
}
```

Можно ли отрефакторить данный код? Если да, то выполните.  
```java
class Entity {
      ...
    private String action;
    public void doSmth() {
        switch(action) {
            case "sing-solo": singSolo(); break;
            case "sing-duet": singDuet(); break;
            case "dance": dance();
        }
    }
    private void singSolo() {
        ...
    }
    private void singDuet() {
        ...
    }
    private void dance() {
        ...
    }
}
```
**Ответ** да, можно  
```java
class Entity {
      ...
    public void doSmth() {
        switch(action) {
            case "sing-solo": doAction(action); break;
            case "sing-duet": doAction(action); break;
            case "dance": doAction(action);
        }
    }
    private void doAction(String action) {
        ...
    }
}
```

Пусть А - абстрактный класс, а - ссылка на А, класс В расширяет класс А. Можно ли создать объект класса В по ссылке а?  
**Ответ** да, можно  
Пусть I - интерфейс, i - ссылка на I, b - ссылка на B, класс В реализует интерфейс I. Можно ли создать объект класса В по ссылке i? Можно ли выполнить операции:  
1. b = i; ?
2. i = b; ?
**Ответ** да, можно  

Можно ли создать:
1. ссылку на объект абстрактного класса?
2. объект абстрактного класса?
3. ссылку на интерфейс?
4. объект типа интерфейс?  
**Ответ.** Ссылку на объект абстрактного класса нельзя создать, тк нельзя создать объект. Ссылку на интерфейс создать можно, но объект создать нельзя.  

Может ли класс:
1. реализовывать два интерфейса?
2. расширять два класса?
3. расширять два интерфейса?
4. расширять один класс и реализовывать один интерфейс?
5. расширять сам себя?  
**Ответ.** 1 - Может. 2 - Не может. 3 - Может. 4 - Может. 5 - Не может.  

Для каких целей используется расширение интерфейса?  
**Ответ.** Если необходимо изменить поведение методов интерфейса, либо для добавления методов.  

Могут ли в интерфейсе быть поля?  
**Ответ.** Интерфейс может содержать только константы и методы.  

Можно ли в интерфейсе
1. объявить метод с пакетным уровнем доступа?
2. объявить конструктор?
3. определить конструктор?  
**Ответ.** 1 - Да. 2 - Нет. 3 - Нет.  
**Источник.** https://overcoder.net/q/36184/конструктор-в-интерфейсе#:~:text=В%20интерфейсе%20есть%20только%20статические,необходимости%20в%20конструкторе%20в%20интерфейсе.&text=Поэтому%20мы%20не%20можем%20определить%20конструктор%20в%20интерфейсах.   

Можно ли интерфейс объявить финальным? Поясните ответ.  
**Ответ.** Нет. Так как методы интерфейса определяют общее поведение, которое может меняться.  

Можно ли в интерфейсе объявить статический метод? Поясните ответ.  
**Ответ.** В java8 можно, но в java7 нельзя.  

Можно ли вызвать статический метод через объектную ссылку? Поясните ответ.  
**Ответ.** Можно, но такой вызов приводит к появлению соответствующего предупреждения и не будет логически корректным, хотя и не закончится ошибкой компиляции.  
**Источник.** И.Блинов, стр.62, стр. 108

Можно ли создать экземпляр класса, у которого есть абстрактный метод? Если да, то зачем?  
**Ответ.** Нет, так как абстрактный метод не может быть создан в неабстрактном классе.  

Должен ли иметь абстрактный класс хотя бы один абстрактный метод? Если нет, то зачем объявлять такой класс абстрактным?  
**Ответ.** Не должен.Такие классы могут использоваться для общего описания подклассов.  
**Источник.** https://askdev.ru/q/ispolzovat-abstraktnyy-klass-bez-abstraktnyh-metodov-251048/

Что означает ключевое слово final в следующих конструкциях?
1.
~~~ java
public final class SomeClass() { }
~~~
2.
~~~ java
public class SomeClass() {
public final void doSmth();
}
~~~
**Ответ.** Модификатор final в имени класса делает недоступным создание для него подклассов, а в имени метода - запрещает заменять сам метод в подклассах.  
**Источник.** И.Блинов, стр.63

Можно ли объявить метод одновременно финальным и абстрактным? Поясните ответ.  
**Ответ.** Нет, так как метод с модификатором abstract должен быть реализован в подклассе, а модификатор final в имени метода запрещает заменять его в подклассах.  

К каким методам неприменимы принципы позднего связывания? Почему?  
**Ответ.** К статическим, т.к. обращение к таким методам осуществляется по типу ссылки, а не по типу объекта, через который производится обращение.  
**Источник.** И.Блинов, стр.107

В чем заключается отличие между ранним и поздним связыванием?  
**Ответ.** Раннее связывание происходит на этапе компиляции, а позднее - во время выполнения, после запуска программы.  
**Источник.** https://javarush.ru/groups/posts/439-razlichija-mezhdu-rannim-i-pozdnim-svjazihvaniem-v-java