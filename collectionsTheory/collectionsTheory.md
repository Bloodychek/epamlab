**Вопрос.** Дайте неформальное определение контейнера.
**Ответ.** Объект, который хранит в себе некоторое количество элементов.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Дайте определение коллекции в java.
**Ответ.** Коллекции — это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих три основные операции:
- добавление нового элемента;
- удаление элемента;
- изменение элемента
**Источник.** Методы программирования, И.Н.Блинов, В.С. Романчик, с.252

**Вопрос.** Какой имеется в java контейнер, отличный от коллекций?
Дайте ему определение.
**Ответ.** Массив — структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов.
**Источник.** https://ru.wikipedia.org/wiki/Массив_(тип_данных)

**Вопрос.** Дайте определение Collections framework?
**Ответ.** Collections framework - это унифицированная архитектура для представления коллекций и управления ими.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Какие разделы содержит Collections framework?
Определите их, и для чего они предназначены?
**Ответ.** Collections framework состоит из:
- Интерфейсы: это абстрактные типы данных, представляющие коллекции. Интерфейсы позволяют управлять коллекциями независимо от их реализаций.
- Имплементации: это конкретные классы коллекций. По сути, это многократно используемые структуры данных.
- Алгоритмы: это методы, которые выполняют полезные вычисления, такие как поиск и сортировка, для объектов, реализующих интерфейсы коллекций. Алгоритмы называются полиморфными: то есть один и тот же метод может использоваться во многих различных реализациях соответствующего интерфейса коллекции.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** В чем преимущества использования Collections Framework
**Ответ.** Платформа Java Collections Framework предоставляет следующие преимущества:
- Снижает затраты на разработку: предоставляя полезные структуры данных и алгоритмы, Collections Framework позволяет сосредоточиться на важных частях вашей программы, а не на низкоуровневой реализации, необходимой для ее работы.
- Повышает скорость и качество программы: эта платформа коллекций обеспечивает высокопроизводительные и высококачественные реализации полезных структур данных и алгоритмов. Различные реализации каждого интерфейса взаимозаменяемы, поэтому программы можно легко настраивать, переключая реализации коллекций.
- Обеспечивает взаимодействие между несвязанными API.
- Снижает усилия по изучению и использованию новых API-интерфейсов.
- Снижает усилия по разработке новых API: это обратная сторона предыдущего преимущества. Разработчикам и разработчикам не нужно изобретать велосипед каждый раз, когда они создают API, основанный на коллекциях; вместо этого они могут использовать стандартные интерфейсы сбора.
- Способствует повторному использованию кода: новые структуры данных, соответствующие стандартным интерфейсам сбора данных, по своей природе допускают повторное использование. То же самое касается новых алгоритмов, которые работают с объектами, реализующими эти интерфейсы.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Является ли антипаттерном следующее объявление ссылки на коллекцию?
Collection collection;
Если да, то как называется антипаттерн и исправьте объявление ссылки.
**Ответ.** Да. Данный код является raw type. Collection<Type> collection`.

**Вопрос.** К каким негативным последствиям может привести использование raw types?
Приведите пример.
**Ответ.**
```java
List list = new ArrayList();
list.add("100");
Integer number = (Integer)list.get(0); //ClassCastException
```
**Источник.** Дж.Блох. Эффективное программирование. ст.23.

**Вопрос.** Почему допускаются raw types с коллекциями?
**Ответ.** Для совместимости. Платформа Java существовала два десятилетия до появления средств обобщённого программирования, и теперь в мире существует огромное количество кода, который их не использует. Критически важно, чтобы этот старый код продолжал компилироваться мог взаимодействовать с новым кодом, использующим средства
обобщённого программирования. Необходимо было разрешить передавать экземпляры параметризованных типов методам, которые были созданы для использования только обычных типов, и наоборот. Это требование, известное как миграционная совместимость (migration compatibility) , привело к решению сохранить поддержку сырых типов.
**Источник.** Дж.Блох. Эффективное программирование. ст.23.

**Вопрос.** Какое главное назначение раздела Интерфейсы?
Другими словами, если известен интерфейс коллекции, то что это дает программисту?
**Ответ.** Если известен интерфейс коллекции, то известен набор методов, которыю будет иметь имплементация,а также общая суть структуры (отсутствие/наличие повторяющихся элементов, порядок извлечения, доступ по индексу/по ключу и т.д, )
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Какое главное назначение раздела Имплементации?
Другими словами, если известна имплементация, то что это дает программисту?
**Ответ.** Тогда известно какие ресурсы (время и память) требуются на выполнение каждой информации
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Приведите иерархию интерфейсов коллекций.
**Ответ.** https://habr.com/ru/post/237043/
**Источник.** https://habr.com/ru/post/237043/

**Вопрос.** Какие существуют способы прохода (traversing) по коллекции до версии java 8 (т.е. от версии 5 до версии 7 включительно)?
Приведите идиомы для следующей коллекции:
Collection<Entity> entities = …;
Какой способ является более подходящим для прохода по коллекции до версии java 8?
**Ответ.** с помощью цикла for-each

```java
for (Entity o : entities)
System.out.println(o);
```
Выбор одного из этих способов зависит от условий и задач. Iterator используется вместо конструкции for-each, когда нужно удалить текущий элемент. Конструкция for-each скрывает итератор, поэтому нельзя вызвать remove. Следовательно, конструкция for-each не может использоваться для фильтрации.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

**Вопрос.** Реализация какого интерфейса позволяет коллекциям использоваться в конструкции for-each?
Какой метод этого интерфейса обеспечивает данную возможность?
**Ответ.** for-each возможен благодаря тому, что все Collection реализуют интерфейс Iterable<T>, который содержит метод `Iterator<T> iterator()`. Объект класса Iterator<T>, в свою очередь, содержит методы next() и hasNext() позволяющие проходить по колллекции
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

**Вопрос.**Что такое итератор?
**Ответ.** Интерфейс Iterator<E> используется для построения объекта, который обеспечивает доступ к элементам коллекции. К этому типу относится объект, возвращаемый методом iterator(). Такой объект позволяет просматривать содержимое коллекции последовательно, элемент за элементом. Позиции итератора располагаются в коллекции между элементами.
**Источник.** Методы программирования, И.Н.Блинов, В.С. Романчик, с.255

**Вопрос.** Дана коллекция из n элементов.
Сколько в ней существует возможных позиций курсора итератора?
**Ответ.** В коллекции, состоящей из N элементов, существует N+1 позиций итератора.
**Источник.** Методы программирования, И.Н.Блинов, В.С. Романчик, с.255

**Вопрос.** Какие методы объявлены в интерфейсе Iterator<E>?
Охарактеризуйте их.
**Ответ.** Методы интерфейса Iterator<E>:
`boolean hasNext()` — проверяет наличие следующего элемента, а в случае его отсутствия (завершения коллекции) возвращает false. Итератор при этом остается неизменным;
`E next()` — возвращает ссылку на объект, на который указывает итератор, и передвигает текущий указатель на следующий, предоставляя доступ к следующему элементу. Если следующий элемент коллекции отсутствует, то метод next() генерирует исключение NoSuchElementException;
`void remove()` — удаляет объект, возвращенный последним вызовом метода next(). Если метод next() до вызова remove() не вызывался, то будет сгенерировано исключение IllegalStateException.
**Источник.** Методы программирования, И.Н.Блинов, В.С. Романчик, с.255

**Вопрос.** В каких случаях следует явно использовать итератор вместо for-each?
**Ответ.** Iterator используется вместо конструкции for-each, когда нужно удалить текущий элемент. Конструкция for-each скрывает итератор, поэтому нельзя вызвать remove. При параллельном переборе нескольких коллекций.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

**Вопрос.** Пусть условие удаления элемента из коллекции Collection<Entity> entities задается методом isRemoved() класса Entity.
Приведите идиому удаления элементов этой коллекции
**Ответ.**
```java
for (Iterator<Entity> it = entities.iterator(); it.hasNext(); )
if (it.next().isRemoved())
it.remove();
```
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

**Вопрос.** Какие группы методов (или операций) объявлены в интерфейсе Collection
(до java 8)?  
Какие методы входят в каждую группу?  
**Ответ.**  
*методы изменения*  
boolean add (E item): добавляет в коллекцию объект item.   При удачном добавлении возвращает true, при неудачном - false  
boolean addAll (Collection<? extends E> col): добавляет в коллекцию все элементы из коллекции col. При удачном добавлении возвращает true, при неудачном - false 
void clear (): удаляет все элементы из коллекции  
boolean remove (Object item): возвращает true, если объект item удачно удален из коллекции, иначе возвращается false 
boolean removeAll (Collection<?> col): удаляет все объекты коллекции col из текущей коллекции. Если текущая коллекция изменилась, возвращает true, иначе возвращается false  
boolean retainAll (Collection<?> col): удаляет все объекты из текущей коллекции, кроме тех, которые содержатся в коллекции col. Если текущая коллекция после удаления изменилась, возвращает true, иначе возвращается false  

*методы перебора*  
Iterator<E> iterator (): возвращает объект Iterator для обхода элементов коллекции  

*методы получения информации*  
boolean contains (Object item): возвращает true, если объект item содержится в коллекции, иначе возвращает false  
boolean isEmpty (): возвращает true, если коллекция пуста, иначе возвращает false
int size (): возвращает число элементов в  
Object[] toArray (): возвращает массив, содержащий все элементы коллекции  
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html#method.summary  

**Вопрос.** В чем разница методов Object[] toArray(), <T> T[] toArray(T[] a) интерфейса Collection?  
**Ответ.**
Object[]toArray() — копирует элементы коллекции в массив объектов.
<T>T[]toArray(T a[]) — копирует элементы коллекции в массив объектов определенного типа.  
**Источник.** Блинов с.255

**Вопрос.** В описании методов интерфейсов коллекций в JavaDoc есть методы, помеченные фразой “optional operation”.  
Modifier and Type 
Method and Description  
boolean
add(E e)
Ensures that this collection contains the specified element (optional operation).  
boolean
addAll(Collection<? extends E> c)
Adds all of the elements in the specified collection to this collection (optional operation).  
void
clear()
Removes all of the elements from this collection (optional operation).  
Как это понимать?    
**Ответ.** То, что метод интерфейса указан как необязательный в JavaDoc, означает, что классы, реализующие этот интерфейс, не обязательно должны реализовывать этот метод. Вместо этого они могли бы, например, создать исключение.  
**Источник.** https://coderoad.ru/8375653/%D0%A7%D1%82%D0%BE-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-optional-operation-%D0%B2-Javadoc-%D0%BD%D0%B0%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-Set-add-E

**Вопрос.** Какую математическую сущность моделирует интерфейс Set?  
**Ответ.** Множество. Интерфейс Set<E>объявляет поведение коллекции, недопускающей дублирования элементов.   
**Источник.** Блинов с.271

**Вопрос.** Какое основное свойство всех имплементаций интерфейса Set, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Set не допускает хранение двух одинаковых элементов. 
**Источник.** https://habr.com/ru/post/162017/

**Вопрос.** Может ли множество содержать null элемент?  
**Ответ.** Да, если не наследуется от интерфейса SortedSet<E>(TreeSet).  

**Вопрос.** Есть ли отношение следования (предыдущий, текущий, следующий элемент) в множестве?  
Если нет, то есть ли у множества итератор?  
**Ответ.** 
Нет, но есть LinkedHashSet который поддерживает связный список элементов набора в том порядке, в котором они вставлялись. Это позволяет организовать упорядоченную итерацию вставки в набор.  
У множества есть метод Iterator<E> iterator() который возвращает итератор по элементам в этом наборе.  
**Источник.** https://www.examclouds.com/java/java-core-russian/navigable-set

**Вопрос.** Как получить элемент множества по индексу?  
**Ответ.** Нельзя. Так как множество это неупорядоченная структура данных, но есть LinkedHashSet в котором можно получить элемент по индексу путем последовательного перебора элементов в множестве.

**Вопрос.** Как реализован метод add() во множестве?   
**Ответ.** Метод add добавляет указанный элемент в Set, если он еще не присутствует, и возвращает логическое значение, указывающее, был ли добавлен элемент.  
**Источник.**  https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

**Вопрос.** Какая группа методов увеличилась в интерфейсе Set по сравнению с интерфейсом Collection?
Какие методы добавились?
**Ответ.** Интерфейс Set содержит только методы, унаследованные от Collection, и добавляет ограничение, запрещающее дублирование элементов. Set также добавляет более строгий контракт на поведение операций equals и hashCode, позволяя осмысленно сравнивать экземпляры Set, даже если их типы реализации различаются. Два экземпляра Set равны, если они содержат одинаковые элементы.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

**Вопрос.** Зависит ли множество, как структура данных, от имплементации?
Обоснуйте ответ.  
**Ответ.** Да. Так как Set является интерфейсом, а классы, его реализующие, используют различные структуры для хранения данных.  

**Вопрос.** Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу HashSet имплементации?
**Ответ.** Для грамотной организации HashSet следует следить, чтобы реализации методов hashCode() и equals()соответствовали контракту.  
**Источник.** Блинов с.271

**Вопрос.** Какие соглашения установлены для переопределения метода hashCode()?  
**Ответ.** Общий контракт hashCode:  
1)Каждый раз, когда он вызывается для одного и того же объекта более одного раза во время выполнения приложения Java, метод hashCode должен последовательно возвращать одно и то же целое число, при условии, что никакая информация, используемая в равных сравнениях для объекта, не изменяется. Это целое число не обязательно должно оставаться согласованным от одного выполнения приложения к другому выполнению того же самого приложения.  
2)Если два объекта равны в соответствии с методом equals (Object), то вызов метода hashCode для каждого из двух объектов должен привести к одинаковому целочисленному результату.  
3)Не требуется, чтобы, если два объекта не равны в соответствии с методом equals (java.lang.Object), тогда вызов метода hashCode для каждого из двух объектов должен давать различные целочисленные результаты. Однако программист должен знать, что получение различных целочисленных результатов для неравных объектов может улучшить производительность хэш-таблиц.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html

**Вопрос.** Почему недостаточно переопределить один только метод hashCode()?  
**Ответ.** Потому что при переопределении метода hashCode() используется метод equals(), следовательно если он не переопределен переопределение hashCode() будет неверным.


**Вопрос.** Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством)?  
~~~java  
@Override
public int hashCode() {
return 22;
}
~~~ 
**Ответ.** Да. реализация соответствует соглашениям установленым для переопределения метода hashCode().  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  

**Вопрос.** Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством HashSet<Entity>)?  
~~~java 
class Entity {
private int value;
public int getValue() {
return value;
}
public void setValue(int value) {
this.value = value;
}
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null || getClass() != obj.getClass()) return false;
Entity entity = (Entity) obj;
return value == entity.value;
}
@Override
public int hashCode() {
int result = 1;
result = result * 31 + value;
return result;
}
}
~~~
**Ответ.**  Да.

**Вопрос.** Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу TreeSet имплементации?  
**Ответ.** Рекомендуется переопределить compare() или compareTo() для внешнего компаратора.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html  

**Вопрос.** В чем заключается актуальность внешнего компаратора?  
**Ответ.** Не нужно переопределять метод compare(). Во внешнем компараторе можно применить собственный алгоритм сравнения и использовать для различных задач различные компараторы.  

**Вопрос.** Дана следующая коллекция:
Collection<Entity> entities = …;
Приведите идиому, позволяющую оставить только уникальные элементы в коллекции при условии правильной реализации класса Entity.  
**Ответ.**
```java
entities = new ArrayList<>(new HashSet<>(entities));
```  

**Вопрос.** Какую математическую сущность моделирует интерфейс List?  
**Ответ.** Последовательность (sequence), или список.  
**Источник.** http://www.quizful.net/post/Java-Collections  

**Вопрос.**  Какое основное свойство всех имплементаций интерфейса List, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Порядок хранения элементов не меняется при добавлении или удалении элементов,доступ к элементам списка осуществляется по индексу.  

**Вопрос.** Может ли имплементация интерфейса List содержать одинаковые элементы?
Обоснуйте ответ.  
**Ответ.** Могут,хотя некоторые реализации содержать ограничения.  
**Источник.**  http://www.seostella.com/ru/article/2012/08/08/kollekcii-collections-v-java-list.html  

**Вопрос.** Какие группы методов увеличились в интерфейсе List по сравнению с интерфейсом Collection?
Какие методы добавились?  
**Ответ.** Были добавлены методы получения объекта по индексу,а также методы
добавления,удаления, редактирования по индексу.  
 
**Вопрос.** Влияют ли изменения внесенные в последовательность, возвращаемый методом subList(), на исходную последовательность?  
**Ответ.** Да,так как он не возвращает новый список, а вид(view) исходного.  
**Источник.** https://habr.com/ru/post/133357/  

**Вопрос.** Дана следующая последовательность: List<Entity> entities = …;
Приведите идиому, позволяющую удалить все элементы с номерами из полусегмента [fromIndex; toIndex).  
**Ответ.** 
```java
entities.subList(fromIndex; toIndex).clear();
```   

**Вопрос.** Дана следующая неупорядоченная последовательность и некоторый элемент для сравнения:
List<Entity> entities = …;
Entity cmpEntity = …;
Приведите идиому для выполнения метода void doAction() класса Entity со всеми элементами последовательности entities, которые совпадают с элементом cmpEntity.
Запрещается упорядочивать последовательность и явно проверять на равенство каждый элемент последовательности.  
**Ответ.**
```java
    List<Entity> tempList = new ArrayList<>(entities);
    tempList.removeAll(Arrays.asList(cmpEntity));
    tempList.forEach((temp) -> temp.doAction());
```


**Вопрос.** Какую математическую сущность моделирует интерфейс Queue?  
**Ответ.** Набор,очередь объектов до обработки.  

**Вопрос.** Какое основное свойство всех имплементаций интерфейса Queue, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Порядок работы с элементами.  

**Вопрос.** Какие группы методов увеличились в интерфейсе Queue по сравнению с интерфейсом Collection?
Какие методы добавились?  
**Ответ.** Добавились методы для обработки(удаления, возврата) и получения элементов в начале очереди,и добавления новых в конец.  

**Вопрос.** Какую математическую сущность моделирует интерфейс Deque?  
**Ответ.** Двухсторонняя очередь.  

**Вопрос.** Какое основное свойство всех имплементаций интерфейса Deque, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Элементы очереди можно использовать и с начала,и с конца.  

**Вопрос.** Какие методы определяет Deque в добавок к методам унаследованным от Queue?  
**Ответ.** Методы доступа к первому и последнему элементам,их удалению,вставке и обработке в двусторонней очереди.  
**Источник.** И.Блинов стр.270.  

**Вопрос.** Верно ли утверждение, что Queue всегда обрабатывает элементы в порядке FIFO?  
**Ответ.** Да,но его наследники могут иметь иной порядок обработки.  

**Вопрос.** Какой элемент независимо от упорядочения Queue будет удален методами remove и poll?  
**Ответ.**  Тот,что находится в голове очереди.  

**Вопрос.** Зачем в интерфейсе Queue метод poll, когда есть remove?  
**Ответ.** Если допустимо,что очередь может быть пустой, то лучше использовать poll(),
т.к. он не генерирует исключение, в то время как remove() может сгенерировать NoSuchElementException.  

**Вопрос.** Какую математическую сущность моделирует интерфейс Map?  
**Ответ.** Словарь, где элемент имеет ключ и значение.  
**Источник.** https://metanit.com/java/tutorial/5.1.php  

**Вопрос.** Какое основное свойство всех имплементаций интерфейса Map, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Они все хранят пару "ключ-значение".  

**Вопрос.** Реализует ли Map интерфейс Collection?  
**Ответ.** Нет.

**Вопрос.** Какую структуру данных представляет собой совокупность
ключей;
значений;
пар ключ-значение
любой имплементации Map?  
**Ответ.** Ключи - множество. Значение - коллекция. Ключ-значение множество. Любая имплементация map - AbstractMap.


**Вопрос.** Какие группы операций определены в интерфейсе Map?  
**Ответ.** CRUD операции, операции интерфейса entry. 

**Вопрос.** Какой интерфейс представляет мультикарту (multimap) в Collections Framework?  
**Ответ.** Map<K, Set<V>>

**Вопрос.** Дана карта:
~~~java
Map<K, V> map = …;
~~~
Приведите идиому для выполнения метода void doAction(K key, V value) со всеми элементами карты.  
**Ответ.**
~~~java
for(Map.Entry<K, V> entry : map.entrySet){
    doAction(entry.getKey(), entry.getValue());
}
~~~

**Вопрос.** Дана карта:
~~~java
Map<K, V> map = …;
~~~
в которой нет элементов со значением null.
Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.  
**Ответ.**
~~~java
for(Map.Entry<K, V> entry : map.entrySet){
    if(entry.getKey().equals(key)){
        doAction(entry.getValue());
        }
}
~~~

**Вопрос.** Дана карта:
~~~java
Map<K, V> map = …;
~~~
в которой есть элементы со значением null.
Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.  
**Ответ.**
~~~java
for(Map.Entry<K, V> entry : map.entrySet){
    if(entry != null){
            if(entry.getKey().equals(key)){
            doAction(entry.getValue());
            }
        }
}
~~~

**Вопрос.** Можно ли отрефакторить следующий код?
Если да, то сделайте это.  
**Ответ.**
~~~java
Purchase purchase = new Purchase("meat", new Byn(100), 10);
System.out.println(purchaseWeekDayMap.get(purchase));
~~~

**Вопрос.** Что возвращает метод put интерфейса Map?  
**Ответ.** Возвращает значение переданного ключа или null, если такого ключа нет.

**Вопрос.** Почему интерфейс Map не расширяет интерфейс Collection в Java Collections Framework?  
**Ответ.** Они не совместимы, т.к. созданы для различных структур данных. Map использует пару ключ-значение.

**Вопрос.** Дайте определение понятию имплементация (Implementation) в контексте Collections Framework.  
**Ответ.** Расширение интерфейса Collection<E>

**Вопрос.** Какие виды имплементаций можно выделить?

**Вопрос.** На что влияет выбор имплементации?

**Вопрос.** Идиома создания пустой коллекции имеет следующий вид:
~~~java
SomeInterface<Entity> entities = new SuitableImplementation<>();
~~~
Почему в левой части идиомы используется ссылка на интерфейс, а не на имплементацию?  
**Ответ.** Это проявление полиморфизма.

**Вопрос.** Укажите наиболее часто используемые имплементации для интерфейсов Collections Framework, а также структуру данных, которая поддерживается данной имплементацией.
Результат представьте в виде таблицы:
Interface	Implementation	Abstract Data Type
-----------------------------------------------------------------------

**Вопрос.** Приведите идиому создания очереди.
~~~java
Xxx<Integer> queue = ...;
~~~
Xxx - это подходящий интерфейс.
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.  
**Ответ.**
~~~java
Queue<Integer> queue = new ArrayDeque<>();
queue.add(1);
queue.add(2);
queue.add(3);
System.out.println(queue.pop())
~~~

**Вопрос.** Приведите идиому создания стека.
~~~java
Xxx<Integer> stack = ...;
~~~
Xxx - это подходящий интерфейс.
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.  
**Ответ.**
~~~java
List<Integer> stack = new Stack<>();
stack.add(1);
stack.add(2);
stack.add(3);
System.out.println(queue.pop())
~~~

**Вопрос:** Когда целесообразно использовать реализацию TreeSet вместо HashSet?  
**Ответ:** TreeSet имеет большую "локальность", если две записи находятся рядом в порядке, a TreeSet помещает их рядом друг с другом в структуре данных и, следовательно, в памяти; это размещение использует принцип локальности, который говорит, что подобные данные часто доступны приложению с одинаковой частотой.
TreeSet полезно, если имеет значение поддержание порядка(с точки зрения значений, а не порядка вставки).  
**Источник:** https://askdev.ru/q/dlya-poiska-hashset-protiv-treeset-2369/

**Вопрос:** Опишите неупорядоченные реализации Map.  
**Ответ:** Это те реализации, которые не имплементируют интерфейс SortedMap

**Вопрос:** Опишите упорядоченные реализации Map.  
**Ответ:** Это те операции, которые имплементируют интерфейс SortedMap

**Вопрос:** Чем отличается ArrayList и LinkedList?  
**Ответ:**
- Операции
- Реализация
- Обработкой
- Объемом памяти  
  **Источник:** https://ru.collaborate-anz.com/linkedlist-vs-arraylist-java#:~:text=ArrayList%20и%20LinkedList%20-%20это,синхронизированы%20с%20помощью%20CollectionsSynchronizedList%20метод

**Вопрос:** Что такое вычислительная сложность операции (алгоритма)?  
**Ответ:** Вычислительная сло́жность — понятие, обозначающее функцию зависимости объёма работы, которая выполняется некоторым алгоритмом, от размера входных данных.  
**Источник:** https://ru.wikipedia.org/wiki/Вычислительная_сложность#:~:text=Вычисли́тельная%20сло́жность%20—%20понятие%20в,сложность%2C%20называется%20теорией%20сложности%20вычислений

**Вопрос:** Укажите вычислительную сложность для операций получения элемента по индексу, поиска, вставки и удаления, для основных коллекций.  
**Ответ:**
- взятие элемента по индексу будет происходить по тому же принципу, что и поиск для других операций — в зависимости от удаленности от конца или начала, т.е. от O(1) до O(n/2).
- для удаления, сперва находится элемент, а потом происходит перезаписывание ссылок — соседи элемента начинают ссылаться друг на друга, теряя ссылки на данный элемент, который впоследствии будет удален сборщиком мусора. То есть, алгоритмическая сложность всё такая же — от O(1) до O(n/2).  
  **Источник:** https://javarush.ru/groups/posts/3452-razbor-voprosov-i-otvetov-s-sobesedovaniy-na-java-razrabotchika-chastjh-10

**Вопрос:** В чем разница между интерфейсами Comparable и Comparator?  
**Ответ:** Comparable - имплементится самим классом, когда нужен натуральный порядок сортировки.
Comparator - имплементится другими классами. Дает возможность отделить реализацию сравнения от класса и сделать несколько реализаций сравнения по разным параметрам для одного класса.  
**Источник:** https://ru.stackoverflow.com/questions/639143/В-чем-разница-между-comparable-и-comparator

**Вопрос:** В чем разница между Iterator и ListIterator?  
**Ответ:**
- Iterator может использоваться для перебора элементов Set, List и Map. В отличие от него, ListIterator может быть использован только для перебора элементов коллекции List
- Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next(). Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous()
- При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove(). Iterator не поддерживает данного функционала  
  **Источник:** https://javastudy.ru/interview/collections/

**Вопрос:** Почему в классе Iterator нет метода для получения следующего элемента без передвижения курсора?  
**Ответ:** Итератор похож на указатель своими основными операциями: он указывает на отдельный элемент коллекции объектов (предоставляет доступ к элементу) и содержит функции для перехода к другому элементу списка (следующему или предыдущему). Контейнер, который реализует поддержку итераторов, должен предоставлять первый элемент списка, а также возможность проверить, перебраны ли все элементы контейнера (является ли итератор конечным). Таким образом без курсора просто нельзя будет реализовать безошибочное передвижение по коллекции.  
**Источник:** https://javastudy.ru/interview/collections/

**Вопрос:** Назовите высокопроизводительные реализации Set для перечислимых типов (enum)?  
**Ответ:**
- of(E e1)
- of(E e1, E e2)
- range(E from, E to)
- allOf(Class<E> elementType)
- copyOf(Collection<E> c)
- copyOf(EnumSet<E> s)
- complementOf(EnumSet<E> s)
- noneOf(Class<E> elementType)
- clone()  
  **Источник:** https://hr-vector.com/java/enumset

**Вопрос:** Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?  
**Ответ:** При удалении произвольного элемента из списка, все элементы, находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак.  
**Источник:** https://github.com/enhorse/java-interview/blob/master/jcf.md

**Вопрос:** Можно ли использовать массив в качестве ключа для HashMap?
Если да, то какие есть особенности.  
**Ответ:** Нет  
**Источник:** https://fooobar.com/questions/261623/can-a-java-array-be-used-as-a-hashmap-key

**Вопрос:** Где определены полиморфные алгоритмы для работы с коллекциями? Опишите основные группы.  
**Ответ:** В классе Collections. Этот класс состоит исключительно из статических методов, которые работают или возвращают коллекции. Он содержит полиморфные алгоритмы, которые используются при работе с коллекциями.
Этот класс содержит методы основных алгоритмов Сollection framework, а именно методы бинарного поиска, сортировка, перемешивание, а также метод, возвращающий обратный порядок элементов и многие другие.  
**Источник:** https://javadevblog.com/obzor-kollektsiy-v-java-java-collections-framework.html

**Вопрос:** В чем заключается назначение метода
Collections.unmodifiableCollection(Collection<? extends T> c)?  
**Ответ:** Метод unmodifiableCollection () класса java.util.Collections используется для возврата неизменяемого представления указанной коллекции.
Этот метод позволяет модулям предоставлять пользователям доступ «только для чтения» к внутренним коллекциям.
Операции запроса в возвращенной коллекции «читаются» в указанной коллекции и пытаются изменить возвращенную коллекцию, либо напрямую, либо через ее итератор, что приводит к исключению UnsupportedOperationException.  
**Источник:** http://espressocode.top/collections-unmodifiablecollection-method-in-java-with-examples/

**Вопрос:** Перечислите различия между массивами и коллекциями?  
**Ответ:** Коллекции, в отличие от массивов, не могут хранить примитивные типы: только типы-классы,
так же в коллекциях можно использовать методы:
- Добавление элемента в список
- Вставка элемента в середину списка
- Поиск элемента в списке
- Удаление элемента из списка  
  **Источник:** https://javarush.ru/quests/lectures/questsyntaxpro.level12.lecture02

**Вопрос:** Массивы и коллекции являются ковариантными или инвариантными?
Поясните ответ.  
**Ответ:** Массивы и коллекции в Java ковариантны. Если бы этого не было, то для использования, например, библиотечного метода, принимающего массив объектов Object[], для работы с массивом строк String[], требовалось бы его сначала скопировать в новый массив Object[].  
**Источник:** https://ru.wikipedia.org/wiki/Ковариантность_и_контравариантность_(программирование)#:~:text=Массивы%20в%20Java%20ковариантны%20с,скопировать%20в%20новый%20массив%20Object.)

**Вопрос:** Дано:
SortedSet<Entity> set = ...;
Найдите в jdk
тип 1, для которого SortedSet<Entity> является подтипом.
подтип 2 для SortedSet<Entity>.
Создайте множество set1 типа 1 и множество set2 подтипа 2. Проверьте правильность, сделав присваивания:
set1 = set;
set = set2;  
**Ответ:**
**Источник:**

**Вопрос:** Массивы и коллекции являются reified (овеществленные) или non-reified типами?
Поясните ответ.  
**Ответ:** Вторым важным отличием массивов от обобщенных типов является то, что массивы являются типами, доступными при выполнении (reified). Это значит, что массивы знают тип элементов во время выполнения и обеспечивают его.
Например, попытавшись сохранить String в массив Long, вы получите исключение ArrayStoreException. Обобщенные типы, напротив, реализуются с использованием затирания (erasure).
Это значит, что они обеспечивают ограничения на типы только на этапе компиляции, а затем отбрасывают (или затирают) информацию о типах элементов при выполнении.
Затирание позволяет обобщенным типам свободно взаимодействовать со старым кодом, который не использует обобщенные типы, обеспечивая плавный переход к обобщенным типам.
В свою очередь, коллекции являются наоборот, non-reified.  
**Источник:** https://ru.stackoverflow.com/questions/1148592/Массивы-и-коллекции-являются-reified-овеществленные-или-non-reified-типами  