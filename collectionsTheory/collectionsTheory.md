**Вопрос.** Дайте неформальное определение контейнера.
**Ответ.** Объект, который хранит в себе некоторое количество элементов.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Дайте определение коллекции в java.
**Ответ.** Коллекции — это хранилища или контейнеры, поддерживающие различные способы накопления и упорядочения объектов с целью обеспечения возможностей эффективного доступа к ним. Они представляют собой реализацию абстрактных структур данных, поддерживающих три основные операции:
- добавление нового элемента;
- удаление элемента;
- изменение элемента
**Источник.** Методы программирования, И.Н.Блинов, В.С. Романчик, с.252

**Вопрос.** Какой имеется в java контейнер, отличный от коллекций?
Дайте ему определение.
**Ответ.** Массив — структура данных, хранящая набор значений (элементов массива), идентифицируемых по индексу или набору индексов.
**Источник.** https://ru.wikipedia.org/wiki/Массив_(тип_данных)

**Вопрос.** Дайте определение Collections framework?
**Ответ.** Collections framework - это унифицированная архитектура для представления коллекций и управления ими.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Какие разделы содержит Collections framework?
Определите их, и для чего они предназначены?
**Ответ.** Collections framework состоит из:
- Интерфейсы: это абстрактные типы данных, представляющие коллекции. Интерфейсы позволяют управлять коллекциями независимо от их реализаций.
- Имплементации: это конкретные классы коллекций. По сути, это многократно используемые структуры данных.
- Алгоритмы: это методы, которые выполняют полезные вычисления, такие как поиск и сортировка, для объектов, реализующих интерфейсы коллекций. Алгоритмы называются полиморфными: то есть один и тот же метод может использоваться во многих различных реализациях соответствующего интерфейса коллекции.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** В чем преимущества использования Collections Framework
**Ответ.** Платформа Java Collections Framework предоставляет следующие преимущества:
- Снижает затраты на разработку: предоставляя полезные структуры данных и алгоритмы, Collections Framework позволяет сосредоточиться на важных частях вашей программы, а не на низкоуровневой реализации, необходимой для ее работы.
- Повышает скорость и качество программы: эта платформа коллекций обеспечивает высокопроизводительные и высококачественные реализации полезных структур данных и алгоритмов. Различные реализации каждого интерфейса взаимозаменяемы, поэтому программы можно легко настраивать, переключая реализации коллекций.
- Обеспечивает взаимодействие между несвязанными API.
- Снижает усилия по изучению и использованию новых API-интерфейсов.
- Снижает усилия по разработке новых API: это обратная сторона предыдущего преимущества. Разработчикам и разработчикам не нужно изобретать велосипед каждый раз, когда они создают API, основанный на коллекциях; вместо этого они могут использовать стандартные интерфейсы сбора.
- Способствует повторному использованию кода: новые структуры данных, соответствующие стандартным интерфейсам сбора данных, по своей природе допускают повторное использование. То же самое касается новых алгоритмов, которые работают с объектами, реализующими эти интерфейсы.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Является ли антипаттерном следующее объявление ссылки на коллекцию?
Collection collection;
Если да, то как называется антипаттерн и исправьте объявление ссылки.
**Ответ.** Да. Данный код является raw type. Collection<Type> collection`.

**Вопрос.** К каким негативным последствиям может привести использование raw types?
Приведите пример.
**Ответ.**
```java
List list = new ArrayList();
list.add("100");
Integer number = (Integer)list.get(0); //ClassCastException
```
**Источник.** Дж.Блох. Эффективное программирование. ст.23.

**Вопрос.** Почему допускаются raw types с коллекциями?
**Ответ.** Для совместимости. Платформа Java существовала два десятилетия до появления средств обобщённого программирования, и теперь в мире существует огромное количество кода, который их не использует. Критически важно, чтобы этот старый код продолжал компилироваться мог взаимодействовать с новым кодом, использующим средства
обобщённого программирования. Необходимо было разрешить передавать экземпляры параметризованных типов методам, которые были созданы для использования только обычных типов, и наоборот. Это требование, известное как миграционная совместимость (migration compatibility) , привело к решению сохранить поддержку сырых типов.
**Источник.** Дж.Блох. Эффективное программирование. ст.23.

**Вопрос.** Какое главное назначение раздела Интерфейсы?
Другими словами, если известен интерфейс коллекции, то что это дает программисту?
**Ответ.** Если известен интерфейс коллекции, то известен набор методов, которыю будет иметь имплементация,а также общая суть структуры (отсутствие/наличие повторяющихся элементов, порядок извлечения, доступ по индексу/по ключу и т.д, )
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Какое главное назначение раздела Имплементации?
Другими словами, если известна имплементация, то что это дает программисту?
**Ответ.** Тогда известно какие ресурсы (время и память) требуются на выполнение каждой информации
**Источник.** https://docs.oracle.com/javase/tutorial/collections/intro/index.html

**Вопрос.** Приведите иерархию интерфейсов коллекций.
**Ответ.** https://habr.com/ru/post/237043/
**Источник.** https://habr.com/ru/post/237043/

**Вопрос.** Какие существуют способы прохода (traversing) по коллекции до версии java 8 (т.е. от версии 5 до версии 7 включительно)?
Приведите идиомы для следующей коллекции:
Collection<Entity> entities = …;
Какой способ является более подходящим для прохода по коллекции до версии java 8?
**Ответ.** с помощью цикла for-each

```java
for (Entity o : entities)
System.out.println(o);
```
Выбор одного из этих способов зависит от условий и задач. Iterator используется вместо конструкции for-each, когда нужно удалить текущий элемент. Конструкция for-each скрывает итератор, поэтому нельзя вызвать remove. Следовательно, конструкция for-each не может использоваться для фильтрации.
**Источник.**
 https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html
//
С итератором забыли
for (Iterator<Entity> it = entities.iterator(); it.hasNext(); ){
    System.out.println(it.next());
//

**Вопрос.** Реализация какого интерфейса позволяет коллекциям использоваться в конструкции for-each?
Какой метод этого интерфейса обеспечивает данную возможность?
**Ответ.** for-each возможен благодаря тому, что все Collection реализуют интерфейс Iterable<T>, который содержит метод `Iterator<T> iterator()`. Объект класса Iterator<T>, в свою очередь, содержит методы next() и hasNext() позволяющие проходить по колллекции
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

**Вопрос.** Что такое итератор?
**Ответ.** Интерфейс Iterator<E> используется для построения объекта, который обеспечивает доступ к элементам коллекции. К этому типу относится объект, возвращаемый методом iterator(). Такой объект позволяет просматривать содержимое коллекции последовательно, элемент за элементом. Позиции итератора располагаются в коллекции между элементами.
**Источник.** Методы программирования, И.Н.Блинов, В.С. Романчик, с.255

**Вопрос.** Дана коллекция из n элементов.
Сколько в ней существует возможных позиций курсора итератора?
**Ответ.** В коллекции, состоящей из N элементов, существует N+1 позиций итератора.
**Источник.** Методы программирования, И.Н.Блинов, В.С. Романчик, с.255

**Вопрос.** Какие методы объявлены в интерфейсе Iterator<E>?
Охарактеризуйте их.
**Ответ.** Методы интерфейса Iterator<E>:
`boolean hasNext()` — проверяет наличие следующего элемента, а в случае его отсутствия (завершения коллекции) возвращает false. Итератор при этом остается неизменным;
`E next()` — возвращает ссылку на объект, на который указывает итератор, и передвигает текущий указатель на следующий, предоставляя доступ к следующему элементу. Если следующий элемент коллекции отсутствует, то метод next() генерирует исключение NoSuchElementException;
`void remove()` — удаляет объект, возвращенный последним вызовом метода next(). Если метод next() до вызова remove() не вызывался, то будет сгенерировано исключение IllegalStateException.
**Источник.** Методы программирования, И.Н.Блинов, В.С. Романчик, с.255

**Вопрос.** В каких случаях следует явно использовать итератор вместо for-each?
**Ответ.** Iterator используется вместо конструкции for-each, когда нужно удалить текущий элемент. Конструкция for-each скрывает итератор, поэтому нельзя вызвать remove. При параллельном переборе нескольких коллекций.
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

**Вопрос.** Пусть условие удаления элемента из коллекции Collection<Entity> entities задается методом isRemoved() класса Entity.
Приведите идиому удаления элементов этой коллекции
**Ответ.**
```java
for (Iterator<Entity> it = entities.iterator(); it.hasNext(); )
if (it.next().isRemoved())
it.remove();
```
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html
**Вопрос.** Какие группы методов (или операций) объявлены в интерфейсе Collection
(до java 8)?  
Какие методы входят в каждую группу?  
**Ответ.**   
 Базовые операции: remove, add, contains, size, isEmpty.

Массовые/обьемные операции: containsAll, addAll, removeAll, retainAll, clear.

Операции c массивом: toArray()

Источник https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html

**Вопрос.** В чем разница методов Object[] toArray(), <T> T[] toArray(T[] a) интерфейса Collection?  
**Ответ.**
Object[]toArray() — копирует элементы коллекции в массив объектов.
<T>T[]toArray(T a[]) — копирует элементы коллекции в массив объектов определенного типа.  
**Источник.** Блинов с.255

**Вопрос.** В описании методов интерфейсов коллекций в JavaDoc есть методы, помеченные фразой “optional operation”.  
Modifier and Type 
Method and Description  
boolean
add(E e)
Ensures that this collection contains the specified element (optional operation).  
boolean
addAll(Collection<? extends E> c)
Adds all of the elements in the specified collection to this collection (optional operation).  
void
clear()
Removes all of the elements from this collection (optional operation).  
Как это понимать?    
**Ответ.** То, что метод интерфейса указан как необязательный в JavaDoc, означает, что классы, реализующие этот интерфейс, не обязательно должны реализовывать этот метод. Вместо этого они могли бы, например, создать исключение.  
**Источник.** https://coderoad.ru/8375653/%D0%A7%D1%82%D0%BE-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-optional-operation-%D0%B2-Javadoc-%D0%BD%D0%B0%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80-Set-add-E

**Вопрос.** Какую математическую сущность моделирует интерфейс Set?  
**Ответ.** Множество. Интерфейс Set<E>объявляет поведение коллекции, недопускающей дублирования элементов.   
**Источник.** Блинов с.271

**Вопрос.** Какое основное свойство всех имплементаций интерфейса Set, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Set не допускает хранение двух одинаковых элементов. 
**Источник.** https://habr.com/ru/post/162017/

**Вопрос.** Может ли множество содержать null элемент?  
**Ответ.** Да и только один.  

**Вопрос.** Есть ли отношение следования (предыдущий, текущий, следующий элемент) в множестве?  
Если нет, то есть ли у множества итератор?  
**Ответ.** 
Нет.  
У множества есть метод Iterator<E> iterator() который возвращает итератор по элементам в этом наборе.   
**Источник** https://www.examclouds.com/java/java-core-russian/navigable-set

**Вопрос.** Как получить элемент множества по индексу?  
**Ответ.** Получить элемент множества по индексу нельзя.  

**Вопрос.** Как реализован метод add() во множестве?   
**Ответ.** Метод add добавляет указанный элемент в Set, если он еще не присутствует, и возвращает логическое значение, указывающее, был ли добавлен элемент.  
**Источник.**  https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html

**Вопрос.** Какая группа методов увеличилась в интерфейсе Set по сравнению с интерфейсом Collection?
Какие методы добавились?
**Ответ.** Интерфейс Set содержит только методы, унаследованные от Collection. Так же у Set есць перегрузки методов containsAll, addAll, retainAll, removeAll, которые принимают Set, как аргумент и соответствуют математическим операциям над множествами.   
**Источник.** https://metanit.com/java/tutorial/5.4.php  

**Вопрос.** Зависит ли множество, как структура данных, от имплементации?
Обоснуйте ответ.  
**Ответ.** Да. Т.к. разные реализации имеют разные способы хранения коллекции. 
**Источник** 
https://docs.oracle.com/javase/tutorial/collections/interfaces/set.html   

**Вопрос.** Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу HashSet имплементации?
**Ответ.** Для грамотной организации HashSet следует следить, чтобы реализации методов hashCode() и equals()соответствовали контракту.  
**Источник.** Блинов с.271

**Вопрос.** Какие соглашения установлены для переопределения метода hashCode()?  
**Ответ.** Общий контракт hashCode:  
1)Каждый раз, когда он вызывается для одного и того же объекта более одного раза во время выполнения приложения Java, метод hashCode должен последовательно возвращать одно и то же целое число, при условии, что никакая информация, используемая в равных сравнениях для объекта, не изменяется. Это целое число не обязательно должно оставаться согласованным от одного выполнения приложения к другому выполнению того же самого приложения.  
2)Если два объекта равны в соответствии с методом equals (Object), то вызов метода hashCode для каждого из двух объектов должен привести к одинаковому целочисленному результату.  
3)Не требуется, чтобы, если два объекта не равны в соответствии с методом equals (java.lang.Object), тогда вызов метода hashCode для каждого из двух объектов должен давать различные целочисленные результаты. Однако программист должен знать, что получение различных целочисленных результатов для неравных объектов может улучшить производительность хэш-таблиц.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html

**Вопрос.** Почему недостаточно переопределить один только метод hashCode()?  
**Ответ.** Потому что при переопределении метода hashCode() используется метод equals(), следовательно если он не переопределен переопределение hashCode() будет неверным.


**Вопрос.** Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством)?  
~~~java  
@Override
public int hashCode() {
return 22;
}
~~~ 
**Ответ.** Данная реализация допустима но является самой плохой из возможных. Такая реализация повлияет на поиск элементов в HashSet. Т.к. потеряется смысл HashSet как структуры данных, потому что значения будут сохраняться в связанный список.  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/lang/Object.html  

**Вопрос.** Являются ли приведенная реализация hashCode() допустимой (в смысле будут ли правильно выполняться все операции над множеством HashSet<Entity>)?  
~~~java 
class Entity {
private int value;
public int getValue() {
return value;
}
public void setValue(int value) {
this.value = value;
}
@Override
public boolean equals(Object obj) {
if (this == obj) return true;
if (obj == null || getClass() != obj.getClass()) return false;
Entity entity = (Entity) obj;
return value == entity.value;
}
@Override
public int hashCode() {
int result = 1;
result = result * 31 + value;
return result;
}
}
~~~
**Ответ.**  
Данная реализация является недопустимой. В HashSet объект по факту является ключем HashMap.  
**Источник**  https://habr.com/ru/post/162017/. Вопрос 13  

**Вопрос.** Какие методы должны быть переопределены в классе, которым параметризовано множество, чтобы гарантировать правильную работу TreeSet имплементации?  
**Ответ.** compareTo().    
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html  

**Вопрос.** В чем заключается актуальность внешнего компаратора?  
**Ответ.** В собственном компараторе можно применить необходимую последовательность полей объектов для сравнения.   

**Вопрос.** Дана следующая коллекция:
Collection<Entity> entities = …;
Приведите идиому, позволяющую оставить только уникальные элементы в коллекции при условии правильной реализации класса Entity.  
**Ответ.**
```java
Collection<Entity> collection = new HashSet<Entity>(entities);
```  

**Вопрос.** Какую математическую сущность моделирует интерфейс List?  
**Ответ.** Последовательность (sequence), или список.  
**Источник.** http://www.quizful.net/post/Java-Collections  

**Вопрос.**  Какое основное свойство всех имплементаций интерфейса List, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Порядок хранения элементов не меняется при добавлении или удалении элементов,доступ к элементам списка осуществляется по индексу.  

**Вопрос.** Может ли имплементация интерфейса List содержать одинаковые элементы?
Обоснуйте ответ.  
**Ответ.** Могут,хотя некоторые реализации содержать ограничения.  
**Источник.**  http://www.seostella.com/ru/article/2012/08/08/kollekcii-collections-v-java-list.html  

**Вопрос.** Какие группы методов увеличились в интерфейсе List по сравнению с интерфейсом Collection?
Какие методы добавились?  
**Ответ.** List добавляет следующие методы:  
void add(int index, Е obj) - вставляет obj в вызывающий список в позицию, указанную в index. Любые ранее вставленные элементы за указанной позицией вставки смещаются вверх. То есть никакие элементы не перезаписываются.  
bооlеаn addAll (int index,Collection<? extends Е> с) - вставляет все элементы в вызывающий список, начиная с позиции, переданной в index. Все ранее существовавшие элементы за точкой вставки смещаются вверх. То есть никакие элементы не перезаписываются. Возвращает true, если вызывающий список изменяется, и false в противном случае.  
Е get (int index) - возвращает объект, сохраненный в указанной позиции вызывающего списка.  
int indexOf(Object obj) - возвращает индекс первого экземпляра obj в вызывающем списке. Если obj не содержится в списке, возвращается 1.  
int lastlndexOf(Object obj) - возвращает индекс последнего экземпляра obj в вызывающем списке. Если obj не содержится в списке, возвращается 1.  
Listlterator listlterator() - возвращает итератор, указывающий на начало списка.  
Listlterator listlterator(int index) - возвращает итератор, указывающий на заданную позицию в списке.  
Е remove(int index) - удаляет элемент из вызывающего списка в позиции index и возвращает удаленный элемент. Результирующий список уплотняется, то есть элементы, следующие за удаленным, сдвигаются на одну позицию назад.  
Е set (int index, Е obj) - присваивает obj элементу, находящемуся в списке в позиции index.  
default void sort(Comparator<? super E> c) - сортирует список, используя заданный компаратор (добавлен в версии JDK 8).  
List subList (int start, int end) - возвращает список, включающий элементы от start до end-1 из вызывающего списка. Элементы из возвращаемого списка также сохраняют ссылки в вызывающем списке.  
**Источник.** https://www.examclouds.com/ru/java/java-core-russian/interface-list  
 
 
**Вопрос.** Влияют ли изменения внесенные в последовательность, возвращаемый методом subList(), на исходную последовательность?  
**Ответ.** Да,так как он не возвращает новый список, а вид(view) исходного.  
**Источник.** https://habr.com/ru/post/133357/  

**Вопрос.** Дана следующая последовательность: List<Entity> entities = …;
Приведите идиому, позволяющую удалить все элементы с номерами из полусегмента [fromIndex; toIndex).  
**Ответ.** 
```java
entities.subList(fromIndex; toIndex).clear();
```   

**Вопрос.** Дана следующая неупорядоченная последовательность и некоторый элемент для сравнения:
List<Entity> entities = …;
Entity cmpEntity = …;
Приведите идиому для выполнения метода void doAction() класса Entity со всеми элементами последовательности entities, которые совпадают с элементом cmpEntity.
Запрещается упорядочивать последовательность и явно проверять на равенство каждый элемент последовательности.  
**Ответ.**
```java
List<Entity> entities;
Entity cmpEntity ;
do{
    int index = entities.indexOf(cmpEntity);
    if(index >= 0){
        entities.get(index).doAction();
        entities.remove(index);
        }
        }while(entities.indexOf(cmpEntity)>=0)
```

**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html  

**Вопрос.** Какую математическую сущность моделирует интерфейс Queue?  
**Ответ.** Никакую, т.к. очередь - структура данных.

**Вопрос.** Какое основное свойство всех имплементаций интерфейса Queue, т.е. что их объединяет независимо от имплементации?  
**Ответ.** 
"первым пришел - первым ушел» (FIFO)"  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/queue.html  

**Вопрос.** Какие группы методов увеличились в интерфейсе Queue по сравнению с интерфейсом Collection?
Какие методы добавились?  
**Ответ.** Добавились методы для обработки(удаления, возврата) и получения элементов в начале очереди,и добавления новых в конец, а именно poll, remove, peek, и element.   
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/deque.html  

**Вопрос.** Какую математическую сущность моделирует интерфейс Deque?  
**Ответ.** Двухсторонняя очередь.  

**Вопрос.** Какое основное свойство всех имплементаций интерфейса Deque, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Элементы очереди можно использовать и с начала,и с конца.  

**Вопрос.** Какие методы определяет Deque в добавок к методам унаследованным от Queue?  
**Ответ.** Методы доступа к первому и последнему элементам,их удалению,вставке и обработке в двусторонней очереди.  
**Источник.** И.Блинов стр.270.  

**Вопрос.** Верно ли утверждение, что Queue всегда обрабатывает элементы в порядке FIFO?  
**Ответ.** Да,но его наследники могут иметь иной порядок обработки.  

**Вопрос.** Какой элемент независимо от упорядочения Queue будет удален методами remove и poll?  
**Ответ.**  Тот,что находится в голове очереди.  

**Вопрос.** Зачем в интерфейсе Queue метод poll, когда есть remove?  
**Ответ.** Если допустимо,что очередь может быть пустой, то лучше использовать poll(),
т.к. он не генерирует исключение, в то время как remove() может сгенерировать NoSuchElementException.  

**Вопрос.** Какую математическую сущность моделирует интерфейс Map?  
**Ответ.** Функцию.  
**Источник.** https://metanit.com/java/tutorial/5.1.php  

**Вопрос.** Какое основное свойство всех имплементаций интерфейса Map, т.е. что их объединяет независимо от имплементации?  
**Ответ.** Ключи не могут повторяться.  

**Вопрос.** Реализует ли Map интерфейс Collection?  
**Ответ.** Нет.

**Вопрос.** Какую структуру данных представляет собой совокупность
ключей;
значений;
пар ключ-значение
любой имплементации Map?   
**Ответ.** Set - ключей;  
Collection - значений;  
Set - пар ключ-значение.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/map.html  

**Вопрос.** Какие группы операций определены в интерфейсе Map?  
**Ответ.** 
Базовые: put, get, containsKey, containsValue, size, isEmpty;   Объемные\массовые: putAll, addAll Операции просмотра коллекций: keySet, values, entrySet.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

**Вопрос.** Какой интерфейс представляет мультикарту (multimap) в Collections Framework?  
**Ответ.** Map<K, Set<V>>

**Вопрос.** Дана карта:
~~~java
Map<K, V> map = …;
~~~
Приведите идиому для выполнения метода void doAction(K key, V value) со всеми элементами карты.  
**Ответ.**
~~~java
for(Map.Entry<K, V> entry : map.entrySet){
    doAction(entry.getKey(), entry.getValue());
}
~~~  

**Вопрос.** Дана карта:
~~~java
Map<K, V> map = …;
~~~
в которой нет элементов со значением null.
Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.  
**Ответ.**
~~~java

if(map.containsKey(key){
    doAction(map.get(key));
        }
~~~
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

**Вопрос.** Дана карта:
~~~java
Map<K, V> map = …;
~~~
в которой есть элементы со значением null.
Приведите идиому для выполнения метода void doAction(V value) с элементом map, заданным ключом K key.  
**Ответ.**
~~~java
if(map.containsKey(key){
    V value = map.get(key);
    if (value != null){
        doAction(value);
        }
}
~~~

**Вопрос.** Можно ли отрефакторить следующий код?
Если да, то сделайте это.  
**Ответ.**
~~~java
   WeekDay purchase = purchaseWeekDayMap.get(purchase);
       if (weekDay != null){
          System.out.println(weekDay);
       }
~~~

**Вопрос.** Что возвращает метод put интерфейса Map?  
**Ответ.** Предыдущее значение, связанное с ключом, или null, если для ключа не было сопоставления. (Возврат null также может указывать на то, что карта ранее связала null с ключом, если реализация поддерживает нулевые значения.)  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/map.html  

**Вопрос.** Почему интерфейс Map не расширяет интерфейс Collection в Java Collections Framework?  
**Ответ.** Они не совместимы, т.к. созданы для различных структур данных. Map использует пару ключ-значение.

**Вопрос.** Дайте определение понятию имплементация (Implementation) в контексте Collections Framework.  
**Ответ.** Имплементация - это объект, реализующий конкретный интерфейс.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/index.html  

**Вопрос.** Какие виды имплементаций можно выделить?  
**Ответ.** General-purpose implementations  
Special-purpose implementations  
Concurrent implementations  
Wrapper implementations  
Convenience implementations  
Abstract implementations  
**Источник** https://docs.oracle.com/javase/tutorial/collections/implementations/index.html  

**Вопрос.** На что влияет выбор имплементации?  
**Ответ.** Выбор имплементации влияет на производительность коллекции и сортированность колекции.  

**Вопрос.** Идиома создания пустой коллекции имеет следующий вид:
~~~java
SomeInterface<Entity> entities = new SuitableImplementation<>();
~~~
Почему в левой части идиомы используется ссылка на интерфейс, а не на имплементацию?  
**Ответ.** Такая идиома создания коллекции позволяет дальнейшему коду не зависеть от типа коллекции, таким образом замена реализации теоретически поребует изменения только данной строчки.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/collection.html  

**Вопрос.** Укажите наиболее часто используемые имплементации для интерфейсов Collections Framework, а также структуру данных, которая поддерживается данной имплементацией.
Результат представьте в виде таблицы:
**Ответ.**  
Interface	Implementation	Abstract Data Type
-----------------------------------------------------------------------
Set	HashSet, TreeSet	множество
Set	LinkedHashSet. HashSet	не сортированное множетсво
Queue	LinkedList	FIFO очередь
Deque	ArrayDeque, LinkedList	FIFO и LIFO очередь
Map	HashMap, TreeMap, LinkedHashMap	множество пар - ключ значение  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces

**Вопрос.** Приведите идиому создания очереди.
~~~java
Xxx<Integer> queue = ...;
~~~
Xxx - это подходящий интерфейс.
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.  
**Ответ.**
~~~java
Queue<Integer> queue = new ArrayDeque<>();
queue.add(1);
queue.add(2);
queue.add(3);
System.out.println(queue.pop())
~~~

**Вопрос.** Приведите идиому создания стека.
~~~java
Xxx<Integer> stack = ...;
~~~
Xxx - это подходящий интерфейс.
Добавьте 3 элемента и удалите 1, выведя содержимое на консоль.  
**Ответ.**
~~~java
Deque<Integer> stack = new ArrayDeque<>();
stack.push(1);
stack.push(2);
stack.push(3);
System.out.println(stack.pop());
for (Integer element : stack) {
    System.out.println(element);
}
~~~
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html https://docs.oracle.com/javase/tutorial/collections/interfaces/deque.html  

**Вопрос.** Когда целесообразно использовать реализацию TreeSet вместо HashSet?  
**Ответ.**  В случае, когда нужно использовать операции в интерфейсе SortedSet или если требуется упорядоченная определенным образом коллекция.  
**Источник.**  https://docs.oracle.com/javase/tutorial/collections/implementations/set.html  

**Вопрос.** Опишите неупорядоченные реализации Map.  
**Ответ.**   
HashMap - Эта реализация предоставляет все необязательные операции Map и допускает нулевые значения и нулевой ключ. (Класс HashMap примерно эквивалентен Hashtable, за исключением того, что он несинхронизирован и допускает значения NULL.)  
WeakHashMap - Реализация интерфейса Map на основе хэш-таблицы со "слабыми" ключами. Запись в WeakHashMap будет автоматически удалена, когда ее ключ больше не используется в обычном режиме.  
Hashtable - Hashtable хранит пары ключей/значений в хэш-таблице. Используя Hashtable, вы указываете объект, который используется как ключ, и значение, которое вы ходите связать с этим ключом. Этот ключ затем хэшируется, а полученный хэш-код используется как индекс, в котором значение хранится в таблице.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/implementations/map.html  

**Вопрос.** Опишите упорядоченные реализации Map.  
**Ответ.**   
TreeMap - Реализация на основе красно-черного дерева. Map сортируется в соответствии с естественным порядком ее ключей или компаратором, предоставленным во время создания Map, в зависимости от того, какой конструктор используется.  
EnumMap - Специализированная реализация Map для использования с ключами перечислимого типа. Все ключи в Map перечисления должны быть одного типа перечисления, который указывается явно или неявно при создании карты. EnumMap представлены внутри как массивы.  
LinkedHashMap - Поддерживает двусвязный список. Этот связанный список определяет порядок итераций, который обычно является порядком, в котором ключи были вставлены в карту (порядок вставки).  
**Источник.** hhttps://docs.oracle.com/javase/8/docs/api/java/util/EnumMap.html https://docs.oracle.com/javase/tutorial/collections/implementations/map.html  

**Вопрос.** Чем отличается ArrayList и LinkedList?  
**Ответ.**
- Операции
- Реализация
- Обработкой
- Объемом памяти  
ArrayList это список, реализованный на основе массива, а LinkedList — это классический связный список, основанный на объектах с ссылками между ними.  
**Источник.** https://ru.collaborate-anz.com/linkedlist-vs-arraylist-java#:~:text=ArrayList%20и%20LinkedList%20-%20это,синхронизированы%20с%20помощью%20CollectionsSynchronizedList%20метод

**Вопрос.** Что такое вычислительная сложность операции (алгоритма)?  
**Ответ.** Вычислительная сло́жность — понятие, обозначающее функцию зависимости объёма работы, которая выполняется некоторым алгоритмом, от размера входных данных.  
**Источник.** https://ru.wikipedia.org/wiki/Вычислительная_сложность#:~:text=Вычисли́тельная%20сло́жность%20—%20понятие%20в,сложность%2C%20называется%20теорией%20сложности%20вычислений

**Вопрос.** Укажите вычислительную сложность для операций получения элемента по индексу, поиска, вставки и удаления, для основных коллекций.  
**Ответ.**  
ArrayList  
add(Object o) – O(1) - вставка в конец  
add(index, element) – в среднем O(n)  
get(int index) – O(1)  
remove() – O(n)  
indexOf(int index) - O(n)  
contains() – O(n)  

LinkedList  
add() – O(1)  
get() – O(n)  
remove() - O(1)  
contains() – O(n)  

HashSet, LinkedHashSet, and EnumSet  
add(), remove() and contains() - O(1)  
**Источник.** https://www.baeldung.com/java-collections-complexity

**Вопрос.** В чем разница между интерфейсами Comparable и Comparator?  
**Ответ.**  
Comparator - это отдельный класс реализующий интерфейс Comparator. Он сравнивает два объекта другого класса.  
Comparable - это итерфейс который реализует сравниваемый класс. При его использовании объект будет сравнивать себя и другой объект.  
**Источник.** https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html

**Вопрос.** В чем разница между Iterator и ListIterator?  
**Ответ.**
- Iterator может использоваться для перебора элементов Set, List и Map. В отличие от него, ListIterator может быть использован только для перебора элементов коллекции List
- Iterator позволяет перебирать элементы только в одном направлении, при помощи метода next(). Тогда как ListIterator позволяет перебирать список в обоих направлениях, при помощи методов next() и previous()
- При помощи ListIterator вы можете модифицировать список, добавляя/удаляя элементы с помощью методов add() и remove(). Iterator не поддерживает данного функционала  
**Источник.** https://javastudy.ru/interview/collections/

**Вопрос.** Почему в классе Iterator нет метода для получения следующего элемента без передвижения курсора?  
**Ответ.** Итератор похож на указатель своими основными операциями: он указывает на отдельный элемент коллекции объектов (предоставляет доступ к элементу) и содержит функции для перехода к другому элементу списка (следующему или предыдущему). Контейнер, который реализует поддержку итераторов, должен предоставлять первый элемент списка, а также возможность проверить, перебраны ли все элементы контейнера (является ли итератор конечным). Таким образом без курсора просто нельзя будет реализовать безошибочное передвижение по коллекции.  
**Источник.** https://javastudy.ru/interview/collections/

**Вопрос.** Назовите высокопроизводительные реализации Set для перечислимых типов (enum)?   
**Ответ.**
EnumSet  
**Источник.** https://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html  

**Вопрос.** Как происходит удаление элементов из ArrayList? Как меняется в этом случае размер ArrayList?  
**Ответ.** При удалении произвольного элемента из списка, все элементы, находящиеся «правее» смещаются на одну ячейку влево и реальный размер массива (его емкость, capacity) не изменяется никак.  
**Источник.** https://github.com/enhorse/java-interview/blob/master/jcf.md

**Вопрос.** Можно ли использовать массив в качестве ключа для HashMap?
Если да, то какие есть особенности.  
**Ответ.** Нет.  
**Источник.** https://fooobar.com/questions/261623/can-a-java-array-be-used-as-a-hashmap-key

**Вопрос.** Где определены полиморфные алгоритмы для работы с коллекциями? Опишите основные группы.  
**Ответ.** В классе Collections. Этот класс состоит исключительно из статических методов, которые работают или возвращают коллекции. Он содержит полиморфные алгоритмы, которые используются при работе с коллекциями.
Этот класс содержит методы основных алгоритмов Сollection framework, а именно методы бинарного поиска, сортировка, перемешивание, а также метод, возвращающий обратный порядок элементов и многие другие.  
**Источник.** https://javadevblog.com/obzor-kollektsiy-v-java-java-collections-framework.html

**Вопрос.** В чем заключается назначение метода
Collections.unmodifiableCollection(Collection<? extends T> c)?  
**Ответ.** Метод unmodifiableCollection () класса java.util.Collections используется для возврата неизменяемого представления указанной коллекции.
Этот метод позволяет модулям предоставлять пользователям доступ «только для чтения» к внутренним коллекциям.
Операции запроса в возвращенной коллекции «читаются» в указанной коллекции и пытаются изменить возвращенную коллекцию, либо напрямую, либо через ее итератор, что приводит к исключению UnsupportedOperationException.  
**Источник.** http://espressocode.top/collections-unmodifiablecollection-method-in-java-with-examples/

**Вопрос.** Перечислите различия между массивами и коллекциями?  
**Ответ.** 
массивы фиксированы по размеру, а размер коллекций не фиксированы  
массивы более производительны чем коллекции  
массивы могут содержать примитивные типы а коллекции нет  
массивы ковариантыны, коллекции - нет  
массивы - reified, коллееции non-reified  
**Источник.** Effective Java Joshua Bloch second edition, стр 175  

**Вопрос.** Массивы и коллекции являются ковариантными или инвариантными?
Поясните ответ.  
**Ответ.** 
массивы - ковариантны  
коллекции - инвариантны  
**Источник.** https://ru.wikipedia.org/wiki/Ковариантность_и_контравариантность_(программирование)#:~:text=Массивы%20в%20Java%20ковариантны%20с,скопировать%20в%20новый%20массив%20Object.)

**Вопрос.** Дано:
SortedSet<Entity> set = ...;
Найдите в jdk
тип 1, для которого SortedSet<Entity> является подтипом.
подтип 2 для SortedSet<Entity>.
Создайте множество set1 типа 1 и множество set2 подтипа 2. Проверьте правильность, сделав присваивания:
set1 = set;
set = set2;  
**Ответ.**
Тип 1 Set<Entity> - супер интерфейс SortedSet.  
Тип 2 NavigableSet<Entity> - подтип SortedSet.  
~~~java
Set<Entity> set1 = new HashSet<>();
        SortedSet<Entity> set = new  TreeSet<>();
        NavigableSet<Entity> set2 = new TreeSet<>();
        set1 = set;
        set = set2;     
~~~
**Источник.** https://docs.oracle.com/javase/8/docs/api/java/util/Set.html https://docs.oracle.com/javase/8/docs/api/java/util/SortedSet.html https://docs.oracle.com/javase/8/docs/api/java/util/NavigableSet.html  

**Вопрос.** Массивы и коллекции являются reified (овеществленные) или non-reified типами?
Поясните ответ.  
**Ответ.** Вторым важным отличием массивов от обобщенных типов является то, что массивы являются типами, доступными при выполнении (reified). Это значит, что массивы знают тип элементов во время выполнения и обеспечивают его.
Например, попытавшись сохранить String в массив Long, вы получите исключение ArrayStoreException. Обобщенные типы, напротив, реализуются с использованием затирания (erasure).
Это значит, что они обеспечивают ограничения на типы только на этапе компиляции, а затем отбрасывают (или затирают) информацию о типах элементов при выполнении.
Затирание позволяет обобщенным типам свободно взаимодействовать со старым кодом, который не использует обобщенные типы, обеспечивая плавный переход к обобщенным типам.
В свою очередь, коллекции являются наоборот, non-reified.  
**Источник.** https://ru.stackoverflow.com/questions/1148592/Массивы-и-коллекции-являются-reified-овеществленные-или-non-reified-типами  